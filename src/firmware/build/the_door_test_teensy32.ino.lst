
/Users/isaacrex/Library/Mobile Documents/com~apple~CloudDocs/Projects/The Door/src/build/the_door_test_teensy32.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
		*p |= (((c & 0x8) >> 3) | ((c & 0x4) << 6) | ((c & 0x2) << 15) | ((c & 0x1) << 24)) << strip;
	}
}

int OctoWS2811::getPixel(uint32_t num)
{
       0:	00 80 00 20 bd 01 00 00 31 14 00 00 f1 13 00 00     ... ....1.......
	uint8_t bit, *p;
	int color=0;

	strip = num / stripLen;
	offset = num % stripLen;
	bit = (1<<strip);
      10:	f1 13 00 00 f1 13 00 00 f1 13 00 00 f1 13 00 00     ................
	if ((params & 0x1F) < 6) {
		p = ((uint8_t *)drawBuffer) + offset * 24;
      20:	f1 13 00 00 f1 13 00 00 f1 13 00 00 31 14 00 00     ............1...
	int color=0;
      30:	31 14 00 00 f1 13 00 00 65 25 00 00 6d 25 00 00     1.......e%..m%..
		for (mask = (1<<23) ; mask ; mask >>= 1) {
			if (*p++ & bit) color |= mask;
      40:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
		}
		switch (params & 7) {
      50:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
			case WS2811_RBG:
				color = (color&0xFF0000) | ((color<<8)&0x00FF00) | ((color>>8)&0x0000FF);
      60:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
				break;
			case WS2811_GRB:
				color = ((color<<8)&0xFF0000) | ((color>>8)&0x00FF00) | (color&0x0000FF);
      70:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
      80:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
				break;
			case WS2811_GBR:
				color = ((color<<8)&0xFFFF00) | ((color>>16)&0x0000FF);
      90:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
				break;
			case WS2811_BRG:
				color = ((color<<16)&0xFF0000) | ((color>>8)&0x00FFFF);
				break;
			case WS2811_BGR:
				color = ((color<<16)&0xFF0000) | (color&0x00FF00) | ((color>>16)&0x0000FF);
      a0:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
      b0:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
	int color=0;
      c0:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
				break;
		}
	} else {
		p = ((uint8_t *)drawBuffer) + offset * 32;
		for (mask = (1<<31) ; mask ; mask >>= 1) {
			if (*p++ & bit) color |= mask;
      d0:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
		}
		switch (params & 0x1F) {
      e0:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
      f0:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
     100:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
     110:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
     120:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
     130:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
     140:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
			case WS2811_RGBW:
				color = ((color<<24)&0xFF000000) | ((color>>8)&0x00FF0000) | ((color>>8)&0x0000FF00) | ((color>>8)&0x000000FF);
				break;
			case WS2811_RBGW:
				color = ((color<<24)&0xFF000000) | ((color>>8)&0x00FF0000) | (color&0x0000FF00) | ((color>>16)&0x000000FF);
     150:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
				break;
     160:	31 14 00 00 e9 17 00 00 31 14 00 00 31 14 00 00     1.......1...1...
			case WS2811_GRBW:
				color = ((color<<24)&0xFF000000) | (color&0x00FF0000) | ((color>>16)&0x0000FF00) | ((color>>8)&0x000000FF);
     170:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
				break;
			case WS2811_GBRW:
				color = ((color<<24)&0xFF000000) | ((color<<8)&0x00FF0000) | ((color>>16)&0x0000FF00) | ((color>>16)&0x000000FF);
     180:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
     190:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
				break;
			case WS2811_BRGW:
				color = ((color<<24)&0xFF000000) | (color&0x00FF0000) | (color&0x0000FF00) | ((color>>24)&0x000000FF);
     1a0:	31 14 00 00 31 14 00 00 31 14 00 00 31 14 00 00     1...1...1...1...
				break;
			case WS2811_BGRW:
				color = ((color<<24)&0xFF000000) | ((color<<8)&0x00FF0000) | ((color>>8)&0x0000FF00) | ((color>>24)&0x000000FF);
     1b0:	31 14 00 00 31 14 00 00 31 14 00 00                 1...1...1...

000001bc <ResetHandler>:
     1bc:	4b57      	ldr	r3, [pc, #348]	; (31c <ResetHandler+0x160>)
				break;
     1be:	f24c 5220 	movw	r2, #50464	; 0xc520
			case WS2811_WRBG:
				color = (color&0xFF000000) | (color&0x00FF0000) | ((color<<8)&0x0000FF00) | ((color>>8)&0x000000FF);
     1c2:	b510      	push	{r4, lr}
     1c4:	81da      	strh	r2, [r3, #14]
     1c6:	f64d 1228 	movw	r2, #55592	; 0xd928
     1ca:	81da      	strh	r2, [r3, #14]
     1cc:	bf00      	nop
				break;
     1ce:	bf00      	nop
			case WS2811_WGRB:
				color = (color&0xFF000000) | ((color<<8)&0x00FF0000) | ((color>>8)&0x0000FF00) | (color&0x000000FF);
     1d0:	f001 f932 	bl	1438 <startup_early_hook>
     1d4:	4b52      	ldr	r3, [pc, #328]	; (320 <ResetHandler+0x164>)
     1d6:	f04f 6210 	mov.w	r2, #150994944	; 0x9000000
     1da:	631a      	str	r2, [r3, #48]	; 0x30
     1dc:	4a51      	ldr	r2, [pc, #324]	; (324 <ResetHandler+0x168>)
     1de:	639a      	str	r2, [r3, #56]	; 0x38
     1e0:	4a51      	ldr	r2, [pc, #324]	; (328 <ResetHandler+0x16c>)
     1e2:	63da      	str	r2, [r3, #60]	; 0x3c
     1e4:	4a51      	ldr	r2, [pc, #324]	; (32c <ResetHandler+0x170>)
     1e6:	6913      	ldr	r3, [r2, #16]
				break;
     1e8:	f413 7380 	ands.w	r3, r3, #256	; 0x100
			case WS2811_WGBR:
				color = (color&0xFF000000) | ((color<<16)&0x00FF0000) | ((color>>8)&0x0000FF00) | ((color>>8)&0x000000FF);
     1ec:	d103      	bne.n	1f6 <ResetHandler+0x3a>
     1ee:	6153      	str	r3, [r2, #20]
     1f0:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     1f4:	6113      	str	r3, [r2, #16]
     1f6:	4b4e      	ldr	r3, [pc, #312]	; (330 <ResetHandler+0x174>)
     1f8:	789a      	ldrb	r2, [r3, #2]
     1fa:	0711      	lsls	r1, r2, #28
     1fc:	d503      	bpl.n	206 <ResetHandler+0x4a>
     1fe:	789a      	ldrb	r2, [r3, #2]
     200:	f042 0208 	orr.w	r2, r2, #8
				break;
     204:	709a      	strb	r2, [r3, #2]
			case WS2811_WBRG:
				color = (color&0xFF000000) | ((color<<8)&0x00FF0000) | ((color<<8)&0x0000FF00) | ((color>>16)&0x000000FF);
     206:	4b4b      	ldr	r3, [pc, #300]	; (334 <ResetHandler+0x178>)
     208:	484b      	ldr	r0, [pc, #300]	; (338 <ResetHandler+0x17c>)
     20a:	222a      	movs	r2, #42	; 0x2a
     20c:	701a      	strb	r2, [r3, #0]
     20e:	4b4b      	ldr	r3, [pc, #300]	; (33c <ResetHandler+0x180>)
     210:	1cda      	adds	r2, r3, #3
     212:	1a12      	subs	r2, r2, r0
     214:	1ec1      	subs	r1, r0, #3
				break;
     216:	f022 0203 	bic.w	r2, r2, #3
			case WS2811_WBGR:
				color = (color&0xFF000000) | ((color<<16)&0x00FF0000) | (color&0x0000FF00) | ((color>>16)&0x000000FF);
     21a:	4299      	cmp	r1, r3
     21c:	bf88      	it	hi
     21e:	2200      	movhi	r2, #0
     220:	4947      	ldr	r1, [pc, #284]	; (340 <ResetHandler+0x184>)
     222:	f001 f811 	bl	1248 <memcpy>
     226:	4b47      	ldr	r3, [pc, #284]	; (344 <ResetHandler+0x188>)
     228:	4847      	ldr	r0, [pc, #284]	; (348 <ResetHandler+0x18c>)
				break;
     22a:	1cda      	adds	r2, r3, #3
			case WS2811_RWGB:
				color = ((color<<8)&0xFF000000) | ((color>>8)&0x00FF0000) | (color&0x0000FF00) | (color&0x000000FF);
     22c:	1a12      	subs	r2, r2, r0
     22e:	1ec1      	subs	r1, r0, #3
     230:	f022 0203 	bic.w	r2, r2, #3
     234:	4299      	cmp	r1, r3
     236:	bf88      	it	hi
     238:	2200      	movhi	r2, #0
     23a:	2100      	movs	r1, #0
     23c:	f002 fa4e 	bl	26dc <memset>
				break;
			case WS2811_RWBG:
				color = ((color<<8)&0xFF000000) | ((color>>8)&0x00FF0000) | ((color<<8)&0x0000FF00) | ((color>>8)&0x000000FF);
     240:	4942      	ldr	r1, [pc, #264]	; (34c <ResetHandler+0x190>)
     242:	4843      	ldr	r0, [pc, #268]	; (350 <ResetHandler+0x194>)
     244:	f44f 72de 	mov.w	r2, #444	; 0x1bc
     248:	f000 fffe 	bl	1248 <memcpy>
     24c:	4b41      	ldr	r3, [pc, #260]	; (354 <ResetHandler+0x198>)
     24e:	4a42      	ldr	r2, [pc, #264]	; (358 <ResetHandler+0x19c>)
     250:	2180      	movs	r1, #128	; 0x80
     252:	f803 1b01 	strb.w	r1, [r3], #1
				break;
     256:	4293      	cmp	r3, r2
			case WS2811_GWRB:
				color = ((color<<8)&0xFF000000) | ((color<<8)&0x00FF0000) | ((color>>16)&0x0000FF00) | (color&0x000000FF);
     258:	d1fb      	bne.n	252 <ResetHandler+0x96>
     25a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     25e:	4a3c      	ldr	r2, [pc, #240]	; (350 <ResetHandler+0x194>)
     260:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
     264:	4b3d      	ldr	r3, [pc, #244]	; (35c <ResetHandler+0x1a0>)
     266:	228a      	movs	r2, #138	; 0x8a
     268:	701a      	strb	r2, [r3, #0]
				break;
     26a:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
			case WS2811_GWBR:
				color = ((color<<8)&0xFF000000) | ((color<<16)&0x00FF0000) | ((color>>16)&0x0000FF00) | ((color>>8)&0x000000FF);
     26e:	2224      	movs	r2, #36	; 0x24
     270:	705a      	strb	r2, [r3, #1]
     272:	22a0      	movs	r2, #160	; 0xa0
     274:	701a      	strb	r2, [r3, #0]
     276:	799a      	ldrb	r2, [r3, #6]
     278:	0792      	lsls	r2, r2, #30
     27a:	d5fc      	bpl.n	276 <ResetHandler+0xba>
     27c:	799a      	ldrb	r2, [r3, #6]
     27e:	06d4      	lsls	r4, r2, #27
     280:	d4fc      	bmi.n	27c <ResetHandler+0xc0>
     282:	4b37      	ldr	r3, [pc, #220]	; (360 <ResetHandler+0x1a4>)
     284:	799a      	ldrb	r2, [r3, #6]
     286:	f002 020c 	and.w	r2, r2, #12
				break;
			case WS2811_BWRG:
				color = ((color<<8)&0xFF000000) | ((color<<8)&0x00FF0000) | ((color<<8)&0x0000FF00) | ((color>>24)&0x000000FF);
     28a:	2a08      	cmp	r2, #8
     28c:	d1fa      	bne.n	284 <ResetHandler+0xc8>
				break;
     28e:	2205      	movs	r2, #5
			case WS2811_BWGR:
				color = ((color<<8)&0xFF000000) | ((color<<16)&0x00FF0000) | (color&0x0000FF00) | ((color>>24)&0x000000FF);
     290:	711a      	strb	r2, [r3, #4]
     292:	2243      	movs	r2, #67	; 0x43
     294:	715a      	strb	r2, [r3, #5]
     296:	799a      	ldrb	r2, [r3, #6]
     298:	0690      	lsls	r0, r2, #26
     29a:	d5fc      	bpl.n	296 <ResetHandler+0xda>
     29c:	4a30      	ldr	r2, [pc, #192]	; (360 <ResetHandler+0x1a4>)
     29e:	7993      	ldrb	r3, [r2, #6]
     2a0:	0659      	lsls	r1, r3, #25
     2a2:	d5fc      	bpl.n	29e <ResetHandler+0xe2>
     2a4:	4b1e      	ldr	r3, [pc, #120]	; (320 <ResetHandler+0x164>)
     2a6:	f04f 7181 	mov.w	r1, #16908288	; 0x1020000
				break;
			case WS2811_RGWB:
				color = ((color<<16)&0xFF000000) | ((color>>8)&0x00FF0000) | ((color>>8)&0x0000FF00) | (color&0x000000FF);
     2aa:	6459      	str	r1, [r3, #68]	; 0x44
     2ac:	2105      	movs	r1, #5
     2ae:	6499      	str	r1, [r3, #72]	; 0x48
     2b0:	2120      	movs	r1, #32
     2b2:	7011      	strb	r1, [r2, #0]
     2b4:	7991      	ldrb	r1, [r2, #6]
     2b6:	f001 010c 	and.w	r1, r1, #12
     2ba:	290c      	cmp	r1, #12
     2bc:	d1fa      	bne.n	2b4 <ResetHandler+0xf8>
     2be:	4a29      	ldr	r2, [pc, #164]	; (364 <ResetHandler+0x1a8>)
     2c0:	605a      	str	r2, [r3, #4]
     2c2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
				break;
			case WS2811_RBWG:
				color = ((color<<16)&0xFF000000) | ((color>>8)&0x00FF0000) | ((color<<8)&0x0000FF00) | ((color>>16)&0x000000FF);
     2c6:	4a28      	ldr	r2, [pc, #160]	; (368 <ResetHandler+0x1ac>)
     2c8:	615a      	str	r2, [r3, #20]
     2ca:	2200      	movs	r2, #0
     2cc:	619a      	str	r2, [r3, #24]
     2ce:	2207      	movs	r2, #7
     2d0:	611a      	str	r2, [r3, #16]
     2d2:	4a26      	ldr	r2, [pc, #152]	; (36c <ResetHandler+0x1b0>)
     2d4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
     2d8:	b662      	cpsie	i
     2da:	f001 f8f3 	bl	14c4 <_init_Teensyduino_internal_>
     2de:	4b13      	ldr	r3, [pc, #76]	; (32c <ResetHandler+0x170>)
				break;
     2e0:	695b      	ldr	r3, [r3, #20]
			case WS2811_GRWB:
				color = ((color<<16)&0xFF000000) | (color&0x00FF0000) | ((color>>16)&0x0000FF00) | (color&0x000000FF);
     2e2:	07da      	lsls	r2, r3, #31
     2e4:	d505      	bpl.n	2f2 <ResetHandler+0x136>
     2e6:	4822      	ldr	r0, [pc, #136]	; (370 <ResetHandler+0x1b4>)
     2e8:	f001 f8e0 	bl	14ac <rtc_set>
     2ec:	4b21      	ldr	r3, [pc, #132]	; (374 <ResetHandler+0x1b8>)
     2ee:	4a22      	ldr	r2, [pc, #136]	; (378 <ResetHandler+0x1bc>)
     2f0:	61da      	str	r2, [r3, #28]
     2f2:	4b22      	ldr	r3, [pc, #136]	; (37c <ResetHandler+0x1c0>)
     2f4:	781b      	ldrb	r3, [r3, #0]
				break;
     2f6:	065b      	lsls	r3, r3, #25
			case WS2811_GBWR:
				color = ((color<<16)&0xFF000000) | ((color<<16)&0x00FF0000) | ((color>>16)&0x0000FF00) | ((color>>16)&0x000000FF);
     2f8:	d509      	bpl.n	30e <ResetHandler+0x152>
     2fa:	4c1e      	ldr	r4, [pc, #120]	; (374 <ResetHandler+0x1b8>)
				break;
     2fc:	4b1e      	ldr	r3, [pc, #120]	; (378 <ResetHandler+0x1bc>)
			case WS2811_BRWG:
				color = ((color<<16)&0xFF000000) | (color&0x00FF0000) | ((color<<8)&0x0000FF00) | ((color>>24)&0x000000FF);
     2fe:	69e2      	ldr	r2, [r4, #28]
     300:	429a      	cmp	r2, r3
     302:	d104      	bne.n	30e <ResetHandler+0x152>
     304:	481a      	ldr	r0, [pc, #104]	; (370 <ResetHandler+0x1b4>)
     306:	f001 f8d1 	bl	14ac <rtc_set>
     30a:	2300      	movs	r3, #0
     30c:	61e3      	str	r3, [r4, #28]
     30e:	f001 f899 	bl	1444 <startup_late_hook>
     312:	f002 fa3b 	bl	278c <__libc_init_array>
				break;
			case WS2811_BGWR:
				color = ((color<<16)&0xFF000000) | ((color<<16)&0x00FF0000) | ((color>>8)&0x0000FF00) | ((color>>24)&0x000000FF);
     316:	f000 ff8e 	bl	1236 <main>
     31a:	e7fe      	b.n	31a <ResetHandler+0x15e>
     31c:	40052000 	.word	0x40052000
     320:	40048000 	.word	0x40048000
			default:
				break;
		}
	}

	return color;
     324:	00043f82 	.word	0x00043f82
     328:	2b000001 	.word	0x2b000001
     32c:	4003d000 	.word	0x4003d000
     330:	4007d000 	.word	0x4007d000
	startup_late_hook();
	__libc_init_array();

	main();
	
	while (1) ;
     334:	4007e000 	.word	0x4007e000
     338:	1fff891c 	.word	0x1fff891c
     33c:	1fff89e4 	.word	0x1fff89e4
     340:	00002abc 	.word	0x00002abc
     344:	1fff8e38 	.word	0x1fff8e38
     348:	1fff89e4 	.word	0x1fff89e4
     34c:	00000000 	.word	0x00000000
     350:	1fff8400 	.word	0x1fff8400
     354:	e000e400 	.word	0xe000e400
     358:	e000e45f 	.word	0xe000e45f
     35c:	40065000 	.word	0x40065000
     360:	40064000 	.word	0x40064000
     364:	000510c0 	.word	0x000510c0
     368:	0001193f 	.word	0x0001193f
     36c:	20200000 	.word	0x20200000
     370:	6570b1be 	.word	0x6570b1be
     374:	4003e000 	.word	0x4003e000
     378:	5a94c3a5 	.word	0x5a94c3a5
     37c:	4007f000 	.word	0x4007f000
     380:	ffffffff 	.word	0xffffffff
     384:	ffffffff 	.word	0xffffffff
     388:	ffffffff 	.word	0xffffffff
     38c:	ffffffff 	.word	0xffffffff
     390:	ffffffff 	.word	0xffffffff
     394:	ffffffff 	.word	0xffffffff
     398:	ffffffff 	.word	0xffffffff
     39c:	ffffffff 	.word	0xffffffff
     3a0:	ffffffff 	.word	0xffffffff
     3a4:	ffffffff 	.word	0xffffffff
     3a8:	ffffffff 	.word	0xffffffff
     3ac:	ffffffff 	.word	0xffffffff
     3b0:	ffffffff 	.word	0xffffffff
     3b4:	ffffffff 	.word	0xffffffff
     3b8:	ffffffff 	.word	0xffffffff
     3bc:	ffffffff 	.word	0xffffffff
     3c0:	ffffffff 	.word	0xffffffff
     3c4:	ffffffff 	.word	0xffffffff
     3c8:	ffffffff 	.word	0xffffffff
     3cc:	ffffffff 	.word	0xffffffff
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <register_tm_clones>:
     410:	4805      	ldr	r0, [pc, #20]	; (428 <register_tm_clones+0x18>)
     412:	4b06      	ldr	r3, [pc, #24]	; (42c <register_tm_clones+0x1c>)
     414:	1a1b      	subs	r3, r3, r0
     416:	0fd9      	lsrs	r1, r3, #31
     418:	eb01 01a3 	add.w	r1, r1, r3, asr #2
     41c:	1049      	asrs	r1, r1, #1
     41e:	d002      	beq.n	426 <register_tm_clones+0x16>
     420:	4b03      	ldr	r3, [pc, #12]	; (430 <register_tm_clones+0x20>)
     422:	b103      	cbz	r3, 426 <register_tm_clones+0x16>
     424:	4718      	bx	r3
     426:	4770      	bx	lr
     428:	1fff89e4 	.word	0x1fff89e4
     42c:	1fff89e4 	.word	0x1fff89e4
     430:	00000000 	.word	0x00000000

00000434 <frame_dummy>:
     434:	b508      	push	{r3, lr}
     436:	4b05      	ldr	r3, [pc, #20]	; (44c <frame_dummy+0x18>)
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4905      	ldr	r1, [pc, #20]	; (450 <frame_dummy+0x1c>)
     43c:	4805      	ldr	r0, [pc, #20]	; (454 <frame_dummy+0x20>)
     43e:	f3af 8000 	nop.w
     442:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     446:	f7ff bfe3 	b.w	410 <register_tm_clones>
     44a:	bf00      	nop
     44c:	00000000 	.word	0x00000000
     450:	1fff89e4 	.word	0x1fff89e4
     454:	00002ab4 	.word	0x00002ab4

00000458 <setup>:

const int config = WS2811_GRB | WS2811_800kHz;

OctoWS2811 leds(leds_per_column, displayMemory, drawingMemory, config);

void setup() {
     458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
class usb_serial_class : public Stream
{
public:
	constexpr usb_serial_class() {}
        void begin(long) {
		uint32_t millis_begin = systick_millis_count;
     45a:	4b27      	ldr	r3, [pc, #156]	; (4f8 <setup+0xa0>)
     45c:	681e      	ldr	r6, [r3, #0]
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() {
		yield();
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     45e:	4c27      	ldr	r4, [pc, #156]	; (4fc <setup+0xa4>)
     460:	4f27      	ldr	r7, [pc, #156]	; (500 <setup+0xa8>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     462:	461d      	mov	r5, r3
		while (!(*this)) {
     464:	e004      	b.n	470 <setup+0x18>
				if (elapsed > 2000) break;
     466:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
     46a:	d810      	bhi.n	48e <setup+0x36>
			yield();
     46c:	f001 ffcc 	bl	2408 <yield>
		yield();
     470:	f001 ffca 	bl	2408 <yield>
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     474:	7823      	ldrb	r3, [r4, #0]
     476:	2b00      	cmp	r3, #0
     478:	d033      	beq.n	4e2 <setup+0x8a>
     47a:	783b      	ldrb	r3, [r7, #0]
     47c:	f013 0f01 	tst.w	r3, #1
     480:	d02f      	beq.n	4e2 <setup+0x8a>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     482:	682b      	ldr	r3, [r5, #0]
     484:	4a1f      	ldr	r2, [pc, #124]	; (504 <setup+0xac>)
     486:	6812      	ldr	r2, [r2, #0]
     488:	1a9b      	subs	r3, r3, r2
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     48a:	2b0e      	cmp	r3, #14
     48c:	d929      	bls.n	4e2 <setup+0x8a>
  Serial.begin(115200);
  // TODO: Adjust the timeout to be on the order of ~2 frames. 
  Serial.setTimeout(100);
     48e:	4c1e      	ldr	r4, [pc, #120]	; (508 <setup+0xb0>)
     490:	2164      	movs	r1, #100	; 0x64
     492:	4620      	mov	r0, r4
     494:	f000 fecd 	bl	1232 <Stream::setTimeout(unsigned long)>
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ if (str == nullptr) return 0;
							  return write((const uint8_t *)str, strlen(str)); }
     498:	6823      	ldr	r3, [r4, #0]
     49a:	685b      	ldr	r3, [r3, #4]
     49c:	2208      	movs	r2, #8
     49e:	491b      	ldr	r1, [pc, #108]	; (50c <setup+0xb4>)
     4a0:	4620      	mov	r0, r4
     4a2:	4798      	blx	r3
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     4a4:	4620      	mov	r0, r4
     4a6:	f000 fe67 	bl	1178 <Print::println()>
  Serial.println("Starting");
  leds.begin();
     4aa:	4819      	ldr	r0, [pc, #100]	; (510 <setup+0xb8>)
     4ac:	f000 f8e2 	bl	674 <OctoWS2811::begin()>
  // Set all LEDs to dim white
  for (int i=0; i < real_num_leds; i++) {
     4b0:	2400      	movs	r4, #0
    // leds.setPixel(i, 0);
    leds.setPixel(i, 0x040404);
     4b2:	4e18      	ldr	r6, [pc, #96]	; (514 <setup+0xbc>)
     4b4:	4d16      	ldr	r5, [pc, #88]	; (510 <setup+0xb8>)
     4b6:	4632      	mov	r2, r6
     4b8:	4621      	mov	r1, r4
     4ba:	4628      	mov	r0, r5
     4bc:	f000 faa0 	bl	a00 <OctoWS2811::setPixel(unsigned long, int)>
  for (int i=0; i < real_num_leds; i++) {
     4c0:	3401      	adds	r4, #1
     4c2:	2c28      	cmp	r4, #40	; 0x28
     4c4:	d1f7      	bne.n	4b6 <setup+0x5e>
							  return write((const uint8_t *)str, strlen(str)); }
     4c6:	4c10      	ldr	r4, [pc, #64]	; (508 <setup+0xb0>)
     4c8:	6823      	ldr	r3, [r4, #0]
     4ca:	685b      	ldr	r3, [r3, #4]
     4cc:	221d      	movs	r2, #29
     4ce:	4912      	ldr	r1, [pc, #72]	; (518 <setup+0xc0>)
     4d0:	4620      	mov	r0, r4
     4d2:	4798      	blx	r3
	size_t println(const char s[])			{ return print(s) + println(); }
     4d4:	4620      	mov	r0, r4
     4d6:	f000 fe4f 	bl	1178 <Print::println()>
  }
  Serial.println("Setting all LEDs to dim white");
  leds.show();
     4da:	480d      	ldr	r0, [pc, #52]	; (510 <setup+0xb8>)
     4dc:	f000 fa1e 	bl	91c <OctoWS2811::show()>
}
     4e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			uint32_t elapsed = systick_millis_count - millis_begin;
     4e2:	682b      	ldr	r3, [r5, #0]
     4e4:	1b9b      	subs	r3, r3, r6
			if (usb_configuration) {
     4e6:	7822      	ldrb	r2, [r4, #0]
     4e8:	2a00      	cmp	r2, #0
     4ea:	d1bc      	bne.n	466 <setup+0xe>
				if (elapsed > 750) break;
     4ec:	f240 22ee 	movw	r2, #750	; 0x2ee
     4f0:	4293      	cmp	r3, r2
     4f2:	d9bb      	bls.n	46c <setup+0x14>
     4f4:	e7cb      	b.n	48e <setup+0x36>
     4f6:	bf00      	nop
     4f8:	1fff8b6c 	.word	0x1fff8b6c
     4fc:	1fff8c4c 	.word	0x1fff8c4c
     500:	1fff8c70 	.word	0x1fff8c70
     504:	1fff8c74 	.word	0x1fff8c74
     508:	1fff8924 	.word	0x1fff8924
     50c:	000028ac 	.word	0x000028ac
     510:	1fff8b3c 	.word	0x1fff8b3c
     514:	00040404 	.word	0x00040404
     518:	000028b8 	.word	0x000028b8

0000051c <loop>:

void loop() {
     51c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     520:	b082      	sub	sp, #8
        virtual int read() { return usb_serial_getchar(); }
     522:	f001 fda9 	bl	2078 <usb_serial_getchar>
  // Wait for SOF_FLAG
  int start_char = Serial.read();
  if (start_char == SOF_FLAG) {
     526:	282a      	cmp	r0, #42	; 0x2a
     528:	d002      	beq.n	530 <loop+0x14>
    if (num_bytes == real_num_leds*3) {
      // We received the correct number of bytes, so we can show the frame.
      leds.show();
    } 
  }
}
     52a:	b002      	add	sp, #8
     52c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
							  return write((const uint8_t *)str, strlen(str)); }
     530:	4c27      	ldr	r4, [pc, #156]	; (5d0 <loop+0xb4>)
     532:	6823      	ldr	r3, [r4, #0]
     534:	685b      	ldr	r3, [r3, #4]
     536:	220c      	movs	r2, #12
     538:	4926      	ldr	r1, [pc, #152]	; (5d4 <loop+0xb8>)
     53a:	4620      	mov	r0, r4
     53c:	4798      	blx	r3
	size_t println(const char s[])			{ return print(s) + println(); }
     53e:	4620      	mov	r0, r4
     540:	f000 fe1a 	bl	1178 <Print::println()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     544:	4b24      	ldr	r3, [pc, #144]	; (5d8 <loop+0xbc>)
     546:	681b      	ldr	r3, [r3, #0]
     548:	9301      	str	r3, [sp, #4]
	return ret;
     54a:	f8dd 8004 	ldr.w	r8, [sp, #4]
	}
	size_t readBytes(char *buffer, size_t length) {
		size_t count=0;
     54e:	2400      	movs	r4, #0
		unsigned long startMillis = millis();
		do {
			count += usb_serial_read(buffer + count, length - count);
     550:	4d22      	ldr	r5, [pc, #136]	; (5dc <loop+0xc0>)
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     552:	4f21      	ldr	r7, [pc, #132]	; (5d8 <loop+0xbc>)
			if (count >= length) return count;
		} while(millis() - startMillis < _timeout);
     554:	4e1e      	ldr	r6, [pc, #120]	; (5d0 <loop+0xb4>)
			count += usb_serial_read(buffer + count, length - count);
     556:	f1c4 0178 	rsb	r1, r4, #120	; 0x78
     55a:	1928      	adds	r0, r5, r4
     55c:	f001 fdea 	bl	2134 <usb_serial_read>
     560:	4404      	add	r4, r0
			if (count >= length) return count;
     562:	2c77      	cmp	r4, #119	; 0x77
     564:	d80a      	bhi.n	57c <loop+0x60>
     566:	683b      	ldr	r3, [r7, #0]
     568:	9300      	str	r3, [sp, #0]
	return ret;
     56a:	9b00      	ldr	r3, [sp, #0]
		} while(millis() - startMillis < _timeout);
     56c:	eba3 0308 	sub.w	r3, r3, r8
     570:	68b2      	ldr	r2, [r6, #8]
     572:	4293      	cmp	r3, r2
     574:	d3ef      	bcc.n	556 <loop+0x3a>
	String readString(size_t max = 0 /* 0 means unlimited length */);
	String readStringUntil(char terminator, size_t max = 0 /* 0 means unlimited length */);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
     576:	4b16      	ldr	r3, [pc, #88]	; (5d0 <loop+0xb4>)
     578:	2201      	movs	r2, #1
     57a:	731a      	strb	r2, [r3, #12]
    int num_bytes = Serial.readBytes((char *)drawingMemory, 3*real_num_leds);
     57c:	46a0      	mov	r8, r4
							  return write((const uint8_t *)str, strlen(str)); }
     57e:	4d14      	ldr	r5, [pc, #80]	; (5d0 <loop+0xb4>)
     580:	682b      	ldr	r3, [r5, #0]
     582:	685b      	ldr	r3, [r3, #4]
     584:	2214      	movs	r2, #20
     586:	4916      	ldr	r1, [pc, #88]	; (5e0 <loop+0xc4>)
     588:	4628      	mov	r0, r5
     58a:	4798      	blx	r3
	size_t print(int n)				{ return print((long)n); }
     58c:	4621      	mov	r1, r4
     58e:	4628      	mov	r0, r5
     590:	f000 fe45 	bl	121e <Print::print(long)>
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
     594:	4628      	mov	r0, r5
     596:	f000 fdef 	bl	1178 <Print::println()>
    for (int i=0; i < real_num_leds*3; i++) {
     59a:	4d10      	ldr	r5, [pc, #64]	; (5dc <loop+0xc0>)
     59c:	1e6c      	subs	r4, r5, #1
     59e:	f105 0777 	add.w	r7, r5, #119	; 0x77
     5a2:	f1c5 0501 	rsb	r5, r5, #1
#endif
	void begin(void);

	void setPixel(uint32_t num, int color);
	void setPixel(uint32_t num, uint8_t red, uint8_t green, uint8_t blue) {
		setPixel(num, color(red, green, blue));
     5a6:	4e0f      	ldr	r6, [pc, #60]	; (5e4 <loop+0xc8>)
      int red = drawingMemory8ptr[i];
     5a8:	1929      	adds	r1, r5, r4
     5aa:	f814 3f01 	ldrb.w	r3, [r4, #1]!

	void show(void);
	int busy(void);

	int color(uint8_t red, uint8_t green, uint8_t blue) {
		return (red << 16) | (green << 8) | blue;
     5ae:	021a      	lsls	r2, r3, #8
     5b0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
		setPixel(num, color(red, green, blue));
     5b4:	431a      	orrs	r2, r3
     5b6:	4630      	mov	r0, r6
     5b8:	f000 fa22 	bl	a00 <OctoWS2811::setPixel(unsigned long, int)>
    for (int i=0; i < real_num_leds*3; i++) {
     5bc:	42a7      	cmp	r7, r4
     5be:	d1f3      	bne.n	5a8 <loop+0x8c>
    if (num_bytes == real_num_leds*3) {
     5c0:	f1b8 0f78 	cmp.w	r8, #120	; 0x78
     5c4:	d1b1      	bne.n	52a <loop+0xe>
      leds.show();
     5c6:	4807      	ldr	r0, [pc, #28]	; (5e4 <loop+0xc8>)
     5c8:	f000 f9a8 	bl	91c <OctoWS2811::show()>
}
     5cc:	e7ad      	b.n	52a <loop+0xe>
     5ce:	bf00      	nop
     5d0:	1fff8924 	.word	0x1fff8924
     5d4:	000028d8 	.word	0x000028d8
     5d8:	1fff8b6c 	.word	0x1fff8b6c
     5dc:	1fff89fc 	.word	0x1fff89fc
     5e0:	000028e8 	.word	0x000028e8
     5e4:	1fff8b3c 	.word	0x1fff8b3c

000005e8 <_GLOBAL__sub_I_displayMemory>:
     5e8:	b500      	push	{lr}
     5ea:	b083      	sub	sp, #12
OctoWS2811 leds(leds_per_column, displayMemory, drawingMemory, config);
     5ec:	2302      	movs	r3, #2
     5ee:	9300      	str	r3, [sp, #0]
     5f0:	4b04      	ldr	r3, [pc, #16]	; (604 <_GLOBAL__sub_I_displayMemory+0x1c>)
     5f2:	4a05      	ldr	r2, [pc, #20]	; (608 <_GLOBAL__sub_I_displayMemory+0x20>)
     5f4:	210a      	movs	r1, #10
     5f6:	4805      	ldr	r0, [pc, #20]	; (60c <_GLOBAL__sub_I_displayMemory+0x24>)
     5f8:	f000 f826 	bl	648 <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)>
}
     5fc:	b003      	add	sp, #12
     5fe:	f85d fb04 	ldr.w	pc, [sp], #4
     602:	bf00      	nop
     604:	1fff89fc 	.word	0x1fff89fc
     608:	1fff8200 	.word	0x1fff8200
     60c:	1fff8b3c 	.word	0x1fff8b3c

00000610 <OctoWS2811::isr()>:
{
     610:	b508      	push	{r3, lr}
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
     612:	4b06      	ldr	r3, [pc, #24]	; (62c <OctoWS2811::isr()+0x1c>)
     614:	791a      	ldrb	r2, [r3, #4]
     616:	4b06      	ldr	r3, [pc, #24]	; (630 <OctoWS2811::isr()+0x20>)
     618:	77da      	strb	r2, [r3, #31]
	update_completed_at = micros();
     61a:	f000 ffe3 	bl	15e4 <micros>
     61e:	4b05      	ldr	r3, [pc, #20]	; (634 <OctoWS2811::isr()+0x24>)
     620:	6018      	str	r0, [r3, #0]
	update_in_progress = 0;
     622:	4b05      	ldr	r3, [pc, #20]	; (638 <OctoWS2811::isr()+0x28>)
     624:	2200      	movs	r2, #0
     626:	701a      	strb	r2, [r3, #0]
}
     628:	bd08      	pop	{r3, pc}
     62a:	bf00      	nop
     62c:	1fff8b5c 	.word	0x1fff8b5c
     630:	40008000 	.word	0x40008000
     634:	1fff8b40 	.word	0x1fff8b40
     638:	1fff8b3d 	.word	0x1fff8b3d

0000063c <DMAChannel::~DMAChannel()>:
	~DMAChannel() {
     63c:	b510      	push	{r4, lr}
     63e:	4604      	mov	r4, r0
		release();
     640:	f000 fd44 	bl	10cc <DMAChannel::release()>
	}
     644:	4620      	mov	r0, r4
     646:	bd10      	pop	{r4, pc}

00000648 <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)>:
OctoWS2811::OctoWS2811(uint32_t numPerStrip, void *frameBuf, void *drawBuf, uint8_t config)
     648:	b410      	push	{r4}
	stripLen = numPerStrip;
     64a:	4c06      	ldr	r4, [pc, #24]	; (664 <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)+0x1c>)
     64c:	8021      	strh	r1, [r4, #0]
	frameBuffer = frameBuf;
     64e:	4906      	ldr	r1, [pc, #24]	; (668 <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)+0x20>)
     650:	600a      	str	r2, [r1, #0]
	drawBuffer = drawBuf;
     652:	4a06      	ldr	r2, [pc, #24]	; (66c <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)+0x24>)
     654:	6013      	str	r3, [r2, #0]
	params = config;
     656:	f89d 2004 	ldrb.w	r2, [sp, #4]
     65a:	4b05      	ldr	r3, [pc, #20]	; (670 <OctoWS2811::OctoWS2811(unsigned long, void*, void*, unsigned char)+0x28>)
     65c:	701a      	strb	r2, [r3, #0]
}
     65e:	bc10      	pop	{r4}
     660:	4770      	bx	lr
     662:	bf00      	nop
     664:	1fff8b66 	.word	0x1fff8b66
     668:	1fff8b48 	.word	0x1fff8b48
     66c:	1fff8b44 	.word	0x1fff8b44
     670:	1fff8b64 	.word	0x1fff8b64

00000674 <OctoWS2811::begin()>:
{
     674:	b510      	push	{r4, lr}
	if ((params & 0x1F) < 6) {
     676:	4b95      	ldr	r3, [pc, #596]	; (8cc <OctoWS2811::begin()+0x258>)
     678:	781b      	ldrb	r3, [r3, #0]
     67a:	f003 031f 	and.w	r3, r3, #31
     67e:	2b05      	cmp	r3, #5
		bufsize = stripLen * 24; // RGB formats
     680:	4b93      	ldr	r3, [pc, #588]	; (8d0 <OctoWS2811::begin()+0x25c>)
     682:	881c      	ldrh	r4, [r3, #0]
     684:	bf9a      	itte	ls
     686:	eb04 0444 	addls.w	r4, r4, r4, lsl #1
     68a:	00e4      	lslls	r4, r4, #3
		bufsize = stripLen * 32; // RGBW formats
     68c:	0164      	lslhi	r4, r4, #5
	memset(frameBuffer, 0, bufsize);
     68e:	4622      	mov	r2, r4
     690:	2100      	movs	r1, #0
     692:	4b90      	ldr	r3, [pc, #576]	; (8d4 <OctoWS2811::begin()+0x260>)
     694:	6818      	ldr	r0, [r3, #0]
     696:	f002 f821 	bl	26dc <memset>
	if (drawBuffer) {
     69a:	4b8f      	ldr	r3, [pc, #572]	; (8d8 <OctoWS2811::begin()+0x264>)
     69c:	6818      	ldr	r0, [r3, #0]
     69e:	2800      	cmp	r0, #0
     6a0:	f000 80e2 	beq.w	868 <OctoWS2811::begin()+0x1f4>
		memset(drawBuffer, 0, bufsize);
     6a4:	4622      	mov	r2, r4
     6a6:	2100      	movs	r1, #0
     6a8:	f002 f818 	bl	26dc <memset>
	GPIOD_PCOR = 0xFF;
     6ac:	4b8b      	ldr	r3, [pc, #556]	; (8dc <OctoWS2811::begin()+0x268>)
     6ae:	22ff      	movs	r2, #255	; 0xff
     6b0:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
	pinMode(2, OUTPUT);	// strip #1
     6b4:	2101      	movs	r1, #1
     6b6:	2002      	movs	r0, #2
     6b8:	f000 ff54 	bl	1564 <pinMode>
	pinMode(14, OUTPUT);	// strip #2
     6bc:	2101      	movs	r1, #1
     6be:	200e      	movs	r0, #14
     6c0:	f000 ff50 	bl	1564 <pinMode>
	pinMode(7, OUTPUT);	// strip #3
     6c4:	2101      	movs	r1, #1
     6c6:	2007      	movs	r0, #7
     6c8:	f000 ff4c 	bl	1564 <pinMode>
	pinMode(8, OUTPUT);	// strip #4
     6cc:	2101      	movs	r1, #1
     6ce:	2008      	movs	r0, #8
     6d0:	f000 ff48 	bl	1564 <pinMode>
	pinMode(6, OUTPUT);	// strip #5
     6d4:	2101      	movs	r1, #1
     6d6:	2006      	movs	r0, #6
     6d8:	f000 ff44 	bl	1564 <pinMode>
	pinMode(20, OUTPUT);	// strip #6
     6dc:	2101      	movs	r1, #1
     6de:	2014      	movs	r0, #20
     6e0:	f000 ff40 	bl	1564 <pinMode>
	pinMode(21, OUTPUT);	// strip #7
     6e4:	2101      	movs	r1, #1
     6e6:	2015      	movs	r0, #21
     6e8:	f000 ff3c 	bl	1564 <pinMode>
	pinMode(5, OUTPUT);	// strip #8
     6ec:	2101      	movs	r1, #1
     6ee:	2005      	movs	r0, #5
     6f0:	f000 ff38 	bl	1564 <pinMode>
	switch (params & 0xC0) {
     6f4:	4b75      	ldr	r3, [pc, #468]	; (8cc <OctoWS2811::begin()+0x258>)
     6f6:	781b      	ldrb	r3, [r3, #0]
     6f8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
		frequency = 400000;
     6fc:	4878      	ldr	r0, [pc, #480]	; (8e0 <OctoWS2811::begin()+0x26c>)
     6fe:	4a79      	ldr	r2, [pc, #484]	; (8e4 <OctoWS2811::begin()+0x270>)
     700:	2b40      	cmp	r3, #64	; 0x40
     702:	bf08      	it	eq
     704:	4610      	moveq	r0, r2
	FTM2_SC = 0;
     706:	4a78      	ldr	r2, [pc, #480]	; (8e8 <OctoWS2811::begin()+0x274>)
     708:	2100      	movs	r1, #0
     70a:	6011      	str	r1, [r2, #0]
	FTM2_CNT = 0;
     70c:	6051      	str	r1, [r2, #4]
	uint32_t mod = (F_BUS + frequency / 2) / frequency;
     70e:	4b77      	ldr	r3, [pc, #476]	; (8ec <OctoWS2811::begin()+0x278>)
     710:	eb03 0350 	add.w	r3, r3, r0, lsr #1
     714:	fbb3 f3f0 	udiv	r3, r3, r0
	FTM2_MOD = mod - 1;
     718:	1e58      	subs	r0, r3, #1
     71a:	6090      	str	r0, [r2, #8]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
     71c:	2008      	movs	r0, #8
     71e:	6010      	str	r0, [r2, #0]
	FTM2_C0SC = 0x69;
     720:	2069      	movs	r0, #105	; 0x69
     722:	60d0      	str	r0, [r2, #12]
	FTM2_C1SC = 0x69;
     724:	6150      	str	r0, [r2, #20]
	FTM2_C0V = (mod * WS2811_TIMING_T0H) >> 8;
     726:	ebc3 1003 	rsb	r0, r3, r3, lsl #4
     72a:	f3c0 1097 	ubfx	r0, r0, #6, #24
     72e:	6110      	str	r0, [r2, #16]
	FTM2_C1V = (mod * WS2811_TIMING_T1H) >> 8;
     730:	20b0      	movs	r0, #176	; 0xb0
     732:	fb00 f303 	mul.w	r3, r0, r3
     736:	0a1b      	lsrs	r3, r3, #8
     738:	6193      	str	r3, [r2, #24]
	CORE_PIN32_CONFIG = PORT_PCR_IRQC(1)|PORT_PCR_MUX(3);
     73a:	4b6d      	ldr	r3, [pc, #436]	; (8f0 <OctoWS2811::begin()+0x27c>)
     73c:	4a6d      	ldr	r2, [pc, #436]	; (8f4 <OctoWS2811::begin()+0x280>)
     73e:	649a      	str	r2, [r3, #72]	; 0x48
		TCD->SADDR = &p;
     740:	4b6d      	ldr	r3, [pc, #436]	; (8f8 <OctoWS2811::begin()+0x284>)
     742:	681a      	ldr	r2, [r3, #0]
     744:	486d      	ldr	r0, [pc, #436]	; (8fc <OctoWS2811::begin()+0x288>)
     746:	6010      	str	r0, [r2, #0]
		TCD->SOFF = 0;
     748:	681b      	ldr	r3, [r3, #0]
     74a:	8099      	strh	r1, [r3, #4]
		TCD->SLAST = 0;
     74c:	60d9      	str	r1, [r3, #12]
		TCD->DADDR = &p;
     74e:	4a6c      	ldr	r2, [pc, #432]	; (900 <OctoWS2811::begin()+0x28c>)
     750:	611a      	str	r2, [r3, #16]
		TCD->DOFF = 0;
     752:	8299      	strh	r1, [r3, #20]
		TCD->DLASTSGA = 0;
     754:	6199      	str	r1, [r3, #24]
			TCD->NBYTES = 1;
     756:	2201      	movs	r2, #1
     758:	609a      	str	r2, [r3, #8]
			TCD->ATTR = TCD->ATTR & 0xF8F8;
     75a:	80d9      	strh	r1, [r3, #6]
		if (!(TCD->BITER & DMA_TCD_BITER_ELINK)) {
     75c:	8bda      	ldrh	r2, [r3, #30]
     75e:	f412 4f00 	tst.w	r2, #32768	; 0x8000
     762:	f040 8086 	bne.w	872 <OctoWS2811::begin()+0x1fe>
			if (len > 32767) return;
     766:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
     76a:	d202      	bcs.n	772 <OctoWS2811::begin()+0xfe>
			TCD->BITER = len;
     76c:	b2a2      	uxth	r2, r4
     76e:	83da      	strh	r2, [r3, #30]
			TCD->CITER = len;
     770:	82da      	strh	r2, [r3, #22]
		TCD->CSR |= DMA_TCD_CSR_DREQ;
     772:	8b9a      	ldrh	r2, [r3, #28]
     774:	b292      	uxth	r2, r2
     776:	f042 0208 	orr.w	r2, r2, #8
     77a:	839a      	strh	r2, [r3, #28]
	dma2.sourceBuffer((uint8_t *)frameBuffer, bufsize);
     77c:	4b55      	ldr	r3, [pc, #340]	; (8d4 <OctoWS2811::begin()+0x260>)
     77e:	6819      	ldr	r1, [r3, #0]
		TCD->SADDR = p;
     780:	4b60      	ldr	r3, [pc, #384]	; (904 <OctoWS2811::begin()+0x290>)
     782:	681a      	ldr	r2, [r3, #0]
     784:	6011      	str	r1, [r2, #0]
		TCD->SOFF = 1;
     786:	681b      	ldr	r3, [r3, #0]
     788:	2201      	movs	r2, #1
     78a:	809a      	strh	r2, [r3, #4]
		TCD->NBYTES = 1;
     78c:	609a      	str	r2, [r3, #8]
		TCD->SLAST = -len;
     78e:	4262      	negs	r2, r4
     790:	60da      	str	r2, [r3, #12]
		TCD->BITER = len;
     792:	b2a2      	uxth	r2, r4
     794:	83da      	strh	r2, [r3, #30]
		TCD->CITER = len;
     796:	82da      	strh	r2, [r3, #22]
		TCD->DADDR = &p;
     798:	495b      	ldr	r1, [pc, #364]	; (908 <OctoWS2811::begin()+0x294>)
     79a:	6119      	str	r1, [r3, #16]
		TCD->DOFF = 0;
     79c:	2100      	movs	r1, #0
     79e:	8299      	strh	r1, [r3, #20]
		TCD->DLASTSGA = 0;
     7a0:	6199      	str	r1, [r3, #24]
			TCD->ATTR = TCD->ATTR & 0xF8F8;
     7a2:	80d9      	strh	r1, [r3, #6]
		if (!(TCD->BITER & DMA_TCD_BITER_ELINK)) {
     7a4:	8bd9      	ldrh	r1, [r3, #30]
     7a6:	f411 4f00 	tst.w	r1, #32768	; 0x8000
     7aa:	d172      	bne.n	892 <OctoWS2811::begin()+0x21e>
			if (len > 32767) return;
     7ac:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
     7b0:	d201      	bcs.n	7b6 <OctoWS2811::begin()+0x142>
			TCD->BITER = len;
     7b2:	83da      	strh	r2, [r3, #30]
			TCD->CITER = len;
     7b4:	82da      	strh	r2, [r3, #22]
		TCD->CSR |= DMA_TCD_CSR_DREQ;
     7b6:	8b99      	ldrh	r1, [r3, #28]
     7b8:	b289      	uxth	r1, r1
     7ba:	f041 0108 	orr.w	r1, r1, #8
     7be:	8399      	strh	r1, [r3, #28]
		TCD->SADDR = &p;
     7c0:	4b52      	ldr	r3, [pc, #328]	; (90c <OctoWS2811::begin()+0x298>)
     7c2:	6819      	ldr	r1, [r3, #0]
     7c4:	484d      	ldr	r0, [pc, #308]	; (8fc <OctoWS2811::begin()+0x288>)
     7c6:	6008      	str	r0, [r1, #0]
		TCD->SOFF = 0;
     7c8:	681b      	ldr	r3, [r3, #0]
     7ca:	2100      	movs	r1, #0
     7cc:	8099      	strh	r1, [r3, #4]
		TCD->SLAST = 0;
     7ce:	60d9      	str	r1, [r3, #12]
		TCD->DADDR = &p;
     7d0:	484f      	ldr	r0, [pc, #316]	; (910 <OctoWS2811::begin()+0x29c>)
     7d2:	6118      	str	r0, [r3, #16]
		TCD->DOFF = 0;
     7d4:	8299      	strh	r1, [r3, #20]
		TCD->DLASTSGA = 0;
     7d6:	6199      	str	r1, [r3, #24]
			TCD->NBYTES = 1;
     7d8:	2001      	movs	r0, #1
     7da:	6098      	str	r0, [r3, #8]
			TCD->ATTR = TCD->ATTR & 0xF8F8;
     7dc:	80d9      	strh	r1, [r3, #6]
		if (!(TCD->BITER & DMA_TCD_BITER_ELINK)) {
     7de:	8bd9      	ldrh	r1, [r3, #30]
     7e0:	f411 4f00 	tst.w	r1, #32768	; 0x8000
     7e4:	d163      	bne.n	8ae <OctoWS2811::begin()+0x23a>
			if (len > 32767) return;
     7e6:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
     7ea:	d201      	bcs.n	7f0 <OctoWS2811::begin()+0x17c>
			TCD->BITER = len;
     7ec:	83da      	strh	r2, [r3, #30]
			TCD->CITER = len;
     7ee:	82da      	strh	r2, [r3, #22]
		TCD->CSR |= DMA_TCD_CSR_DREQ;
     7f0:	8b9a      	ldrh	r2, [r3, #28]
     7f2:	b292      	uxth	r2, r2
     7f4:	f042 0208 	orr.w	r2, r2, #8
     7f8:	839a      	strh	r2, [r3, #28]
		TCD->CSR |= DMA_TCD_CSR_INTMAJOR;
     7fa:	8b9a      	ldrh	r2, [r3, #28]
     7fc:	b292      	uxth	r2, r2
     7fe:	f042 0202 	orr.w	r2, r2, #2
     802:	839a      	strh	r2, [r3, #28]
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     804:	4a3c      	ldr	r2, [pc, #240]	; (8f8 <OctoWS2811::begin()+0x284>)
     806:	7913      	ldrb	r3, [r2, #4]
     808:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     80c:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
     810:	2000      	movs	r0, #0
     812:	7018      	strb	r0, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
     814:	21b2      	movs	r1, #178	; 0xb2
     816:	7019      	strb	r1, [r3, #0]
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     818:	493a      	ldr	r1, [pc, #232]	; (904 <OctoWS2811::begin()+0x290>)
     81a:	790b      	ldrb	r3, [r1, #4]
     81c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     820:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
     824:	7018      	strb	r0, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
     826:	24a2      	movs	r4, #162	; 0xa2
     828:	701c      	strb	r4, [r3, #0]
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     82a:	4c38      	ldr	r4, [pc, #224]	; (90c <OctoWS2811::begin()+0x298>)
     82c:	7923      	ldrb	r3, [r4, #4]
     82e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     832:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
     836:	7018      	strb	r0, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
     838:	20a3      	movs	r0, #163	; 0xa3
     83a:	7018      	strb	r0, [r3, #0]
	DMAPriorityOrder(dma3, dma2, dma1);
     83c:	4620      	mov	r0, r4
     83e:	f000 fc5d 	bl	10fc <DMAPriorityOrder(DMAChannel&, DMAChannel&, DMAChannel&)>
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     842:	7922      	ldrb	r2, [r4, #4]
     844:	f102 0110 	add.w	r1, r2, #16
     848:	4b32      	ldr	r3, [pc, #200]	; (914 <OctoWS2811::begin()+0x2a0>)
     84a:	4833      	ldr	r0, [pc, #204]	; (918 <OctoWS2811::begin()+0x2a4>)
     84c:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
     850:	1153      	asrs	r3, r2, #5
     852:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
     856:	3340      	adds	r3, #64	; 0x40
     858:	009b      	lsls	r3, r3, #2
     85a:	f002 021f 	and.w	r2, r2, #31
     85e:	2101      	movs	r1, #1
     860:	fa01 f202 	lsl.w	r2, r1, r2
     864:	601a      	str	r2, [r3, #0]
}
     866:	bd10      	pop	{r4, pc}
		drawBuffer = frameBuffer;
     868:	4b1a      	ldr	r3, [pc, #104]	; (8d4 <OctoWS2811::begin()+0x260>)
     86a:	681a      	ldr	r2, [r3, #0]
     86c:	4b1a      	ldr	r3, [pc, #104]	; (8d8 <OctoWS2811::begin()+0x264>)
     86e:	601a      	str	r2, [r3, #0]
     870:	e71c      	b.n	6ac <OctoWS2811::begin()+0x38>
			if (len > 511) return;
     872:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
     876:	f4bf af7c 	bcs.w	772 <OctoWS2811::begin()+0xfe>
			TCD->BITER = (TCD->BITER & 0xFE00) | len;
     87a:	8bd9      	ldrh	r1, [r3, #30]
     87c:	b2a2      	uxth	r2, r4
     87e:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
     882:	4311      	orrs	r1, r2
     884:	83d9      	strh	r1, [r3, #30]
			TCD->CITER = (TCD->CITER & 0xFE00) | len;
     886:	8ad9      	ldrh	r1, [r3, #22]
     888:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
     88c:	430a      	orrs	r2, r1
     88e:	82da      	strh	r2, [r3, #22]
     890:	e76f      	b.n	772 <OctoWS2811::begin()+0xfe>
			if (len > 511) return;
     892:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
     896:	d28e      	bcs.n	7b6 <OctoWS2811::begin()+0x142>
			TCD->BITER = (TCD->BITER & 0xFE00) | len;
     898:	8bd9      	ldrh	r1, [r3, #30]
     89a:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
     89e:	4311      	orrs	r1, r2
     8a0:	83d9      	strh	r1, [r3, #30]
			TCD->CITER = (TCD->CITER & 0xFE00) | len;
     8a2:	8ad9      	ldrh	r1, [r3, #22]
     8a4:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
     8a8:	4311      	orrs	r1, r2
     8aa:	82d9      	strh	r1, [r3, #22]
     8ac:	e783      	b.n	7b6 <OctoWS2811::begin()+0x142>
			if (len > 511) return;
     8ae:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
     8b2:	d29d      	bcs.n	7f0 <OctoWS2811::begin()+0x17c>
			TCD->BITER = (TCD->BITER & 0xFE00) | len;
     8b4:	8bd9      	ldrh	r1, [r3, #30]
     8b6:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
     8ba:	4311      	orrs	r1, r2
     8bc:	83d9      	strh	r1, [r3, #30]
			TCD->CITER = (TCD->CITER & 0xFE00) | len;
     8be:	8ad9      	ldrh	r1, [r3, #22]
     8c0:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
     8c4:	430a      	orrs	r2, r1
     8c6:	82da      	strh	r2, [r3, #22]
     8c8:	e792      	b.n	7f0 <OctoWS2811::begin()+0x17c>
     8ca:	bf00      	nop
     8cc:	1fff8b64 	.word	0x1fff8b64
     8d0:	1fff8b66 	.word	0x1fff8b66
     8d4:	1fff8b48 	.word	0x1fff8b48
     8d8:	1fff8b44 	.word	0x1fff8b44
     8dc:	400ff000 	.word	0x400ff000
     8e0:	000c3500 	.word	0x000c3500
     8e4:	00061a80 	.word	0x00061a80
     8e8:	400b8000 	.word	0x400b8000
     8ec:	02255100 	.word	0x02255100
     8f0:	4004a000 	.word	0x4004a000
     8f4:	00010300 	.word	0x00010300
     8f8:	1fff8b4c 	.word	0x1fff8b4c
     8fc:	1fff8920 	.word	0x1fff8920
     900:	400ff0c4 	.word	0x400ff0c4
     904:	1fff8b54 	.word	0x1fff8b54
     908:	400ff0c0 	.word	0x400ff0c0
     90c:	1fff8b5c 	.word	0x1fff8b5c
     910:	400ff0c8 	.word	0x400ff0c8
     914:	1fff8400 	.word	0x1fff8400
     918:	00000611 	.word	0x00000611

0000091c <OctoWS2811::show()>:
{
     91c:	b510      	push	{r4, lr}
	while (update_in_progress) ;
     91e:	4a2c      	ldr	r2, [pc, #176]	; (9d0 <OctoWS2811::show()+0xb4>)
     920:	7813      	ldrb	r3, [r2, #0]
     922:	2b00      	cmp	r3, #0
     924:	d1fc      	bne.n	920 <OctoWS2811::show()+0x4>
	if (drawBuffer != frameBuffer) {
     926:	4b2b      	ldr	r3, [pc, #172]	; (9d4 <OctoWS2811::show()+0xb8>)
     928:	6819      	ldr	r1, [r3, #0]
     92a:	4b2b      	ldr	r3, [pc, #172]	; (9d8 <OctoWS2811::show()+0xbc>)
     92c:	6818      	ldr	r0, [r3, #0]
     92e:	4281      	cmp	r1, r0
     930:	d00c      	beq.n	94c <OctoWS2811::show()+0x30>
		if ((params & 0x1F) < 6) {
     932:	4b2a      	ldr	r3, [pc, #168]	; (9dc <OctoWS2811::show()+0xc0>)
     934:	781b      	ldrb	r3, [r3, #0]
     936:	f003 031f 	and.w	r3, r3, #31
     93a:	2b05      	cmp	r3, #5
     93c:	d842      	bhi.n	9c4 <OctoWS2811::show()+0xa8>
			memcpy(frameBuffer, drawBuffer, stripLen * 24);
     93e:	4b28      	ldr	r3, [pc, #160]	; (9e0 <OctoWS2811::show()+0xc4>)
     940:	881a      	ldrh	r2, [r3, #0]
     942:	eb02 0242 	add.w	r2, r2, r2, lsl #1
     946:	00d2      	lsls	r2, r2, #3
     948:	f000 fc7e 	bl	1248 <memcpy>
	while (micros() - update_completed_at < 300) ;
     94c:	4c25      	ldr	r4, [pc, #148]	; (9e4 <OctoWS2811::show()+0xc8>)
     94e:	f000 fe49 	bl	15e4 <micros>
     952:	6823      	ldr	r3, [r4, #0]
     954:	1ac0      	subs	r0, r0, r3
     956:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
     95a:	d3f8      	bcc.n	94e <OctoWS2811::show()+0x32>
	FTM2_C0SC = 0x28;
     95c:	4b22      	ldr	r3, [pc, #136]	; (9e8 <OctoWS2811::show()+0xcc>)
     95e:	2228      	movs	r2, #40	; 0x28
     960:	60da      	str	r2, [r3, #12]
	FTM2_C1SC = 0x28;
     962:	615a      	str	r2, [r3, #20]
	uint32_t cv = FTM2_C0V;
     964:	691b      	ldr	r3, [r3, #16]
	noInterrupts();
     966:	b672      	cpsid	i
	while (FTM2_CNT <= cv) ;
     968:	491f      	ldr	r1, [pc, #124]	; (9e8 <OctoWS2811::show()+0xcc>)
     96a:	684a      	ldr	r2, [r1, #4]
     96c:	429a      	cmp	r2, r3
     96e:	d9fc      	bls.n	96a <OctoWS2811::show()+0x4e>
	while (FTM2_CNT > cv) ; // wait for beginning of an 800 kHz cycle
     970:	491d      	ldr	r1, [pc, #116]	; (9e8 <OctoWS2811::show()+0xcc>)
     972:	684a      	ldr	r2, [r1, #4]
     974:	429a      	cmp	r2, r3
     976:	d8fc      	bhi.n	972 <OctoWS2811::show()+0x56>
	while (FTM2_CNT < cv) ;
     978:	491b      	ldr	r1, [pc, #108]	; (9e8 <OctoWS2811::show()+0xcc>)
     97a:	684a      	ldr	r2, [r1, #4]
     97c:	429a      	cmp	r2, r3
     97e:	d3fc      	bcc.n	97a <OctoWS2811::show()+0x5e>
	FTM2_SC = 0;             // stop FTM2 timer (hopefully before it rolls over)
     980:	4b19      	ldr	r3, [pc, #100]	; (9e8 <OctoWS2811::show()+0xcc>)
     982:	2200      	movs	r2, #0
     984:	601a      	str	r2, [r3, #0]
	FTM2_CNT = 0;
     986:	605a      	str	r2, [r3, #4]
	update_in_progress = 1;
     988:	4a11      	ldr	r2, [pc, #68]	; (9d0 <OctoWS2811::show()+0xb4>)
     98a:	2101      	movs	r1, #1
     98c:	7011      	strb	r1, [r2, #0]
	PORTB_ISFR = (1<<18);    // clear any prior rising edge
     98e:	4a17      	ldr	r2, [pc, #92]	; (9ec <OctoWS2811::show()+0xd0>)
     990:	f44f 2180 	mov.w	r1, #262144	; 0x40000
     994:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
	FTM2_C0SC = 0x28;
     998:	2128      	movs	r1, #40	; 0x28
     99a:	60d9      	str	r1, [r3, #12]
	tmp = FTM2_C0SC;         // clear any prior timer DMA triggers
     99c:	68da      	ldr	r2, [r3, #12]
	FTM2_C0SC = 0x69;
     99e:	2269      	movs	r2, #105	; 0x69
     9a0:	60da      	str	r2, [r3, #12]
	FTM2_C1SC = 0x28;
     9a2:	6159      	str	r1, [r3, #20]
	tmp = FTM2_C1SC;
     9a4:	6959      	ldr	r1, [r3, #20]
	FTM2_C1SC = 0x69;
     9a6:	615a      	str	r2, [r3, #20]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
     9a8:	4a11      	ldr	r2, [pc, #68]	; (9f0 <OctoWS2811::show()+0xd4>)
     9aa:	7911      	ldrb	r1, [r2, #4]
     9ac:	4a11      	ldr	r2, [pc, #68]	; (9f4 <OctoWS2811::show()+0xd8>)
     9ae:	76d1      	strb	r1, [r2, #27]
     9b0:	4911      	ldr	r1, [pc, #68]	; (9f8 <OctoWS2811::show()+0xdc>)
     9b2:	7909      	ldrb	r1, [r1, #4]
     9b4:	76d1      	strb	r1, [r2, #27]
     9b6:	4911      	ldr	r1, [pc, #68]	; (9fc <OctoWS2811::show()+0xe0>)
     9b8:	7909      	ldrb	r1, [r1, #4]
     9ba:	76d1      	strb	r1, [r2, #27]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0); // restart FTM2 timer
     9bc:	2208      	movs	r2, #8
     9be:	601a      	str	r2, [r3, #0]
	interrupts();
     9c0:	b662      	cpsie	i
}
     9c2:	bd10      	pop	{r4, pc}
			memcpy(frameBuffer, drawBuffer, stripLen * 32);
     9c4:	4b06      	ldr	r3, [pc, #24]	; (9e0 <OctoWS2811::show()+0xc4>)
     9c6:	881a      	ldrh	r2, [r3, #0]
     9c8:	0152      	lsls	r2, r2, #5
     9ca:	f000 fc3d 	bl	1248 <memcpy>
     9ce:	e7bd      	b.n	94c <OctoWS2811::show()+0x30>
     9d0:	1fff8b3d 	.word	0x1fff8b3d
     9d4:	1fff8b44 	.word	0x1fff8b44
     9d8:	1fff8b48 	.word	0x1fff8b48
     9dc:	1fff8b64 	.word	0x1fff8b64
     9e0:	1fff8b66 	.word	0x1fff8b66
     9e4:	1fff8b40 	.word	0x1fff8b40
     9e8:	400b8000 	.word	0x400b8000
     9ec:	4004a000 	.word	0x4004a000
     9f0:	1fff8b4c 	.word	0x1fff8b4c
     9f4:	40008000 	.word	0x40008000
     9f8:	1fff8b54 	.word	0x1fff8b54
     9fc:	1fff8b5c 	.word	0x1fff8b5c

00000a00 <OctoWS2811::setPixel(unsigned long, int)>:
{
     a00:	b530      	push	{r4, r5, lr}
	if ((params & 0x1F) < 6) {
     a02:	4b79      	ldr	r3, [pc, #484]	; (be8 <OctoWS2811::setPixel(unsigned long, int)+0x1e8>)
     a04:	781b      	ldrb	r3, [r3, #0]
     a06:	f003 001f 	and.w	r0, r3, #31
     a0a:	2805      	cmp	r0, #5
     a0c:	f200 80cb 	bhi.w	ba6 <OctoWS2811::setPixel(unsigned long, int)+0x1a6>
		switch (params & 7) {
     a10:	f003 0307 	and.w	r3, r3, #7
     a14:	3b01      	subs	r3, #1
     a16:	2b04      	cmp	r3, #4
     a18:	d80d      	bhi.n	a36 <OctoWS2811::setPixel(unsigned long, int)+0x36>
     a1a:	e8df f003 	tbb	[pc, r3]
     a1e:	9f03      	.short	0x9f03
     a20:	b0a9      	.short	0xb0a9
     a22:	b9          	.byte	0xb9
     a23:	00          	.byte	0x00
			color = (color&0xFF0000) | ((color<<8)&0x00FF00) | ((color>>8)&0x0000FF);
     a24:	f402 007f 	and.w	r0, r2, #16711680	; 0xff0000
     a28:	0213      	lsls	r3, r2, #8
     a2a:	b29b      	uxth	r3, r3
     a2c:	f3c2 2207 	ubfx	r2, r2, #8, #8
     a30:	4313      	orrs	r3, r2
     a32:	ea40 0203 	orr.w	r2, r0, r3
		uint32_t strip = num / stripLen;  // Cortex-M4 has 2 cycle unsigned divide :-)
     a36:	4b6d      	ldr	r3, [pc, #436]	; (bec <OctoWS2811::setPixel(unsigned long, int)+0x1ec>)
     a38:	881b      	ldrh	r3, [r3, #0]
     a3a:	fbb1 fcf3 	udiv	ip, r1, r3
		uint32_t offset = num % stripLen;
     a3e:	fb03 131c 	mls	r3, r3, ip, r1
		uint32_t *p = ((uint32_t *) drawBuffer) + offset * 6;
     a42:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     a46:	ea4f 0ec3 	mov.w	lr, r3, lsl #3
     a4a:	4969      	ldr	r1, [pc, #420]	; (bf0 <OctoWS2811::setPixel(unsigned long, int)+0x1f0>)
     a4c:	680c      	ldr	r4, [r1, #0]
     a4e:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
		uint32_t mask32 = (0x01010101) << strip;
     a52:	f04f 3001 	mov.w	r0, #16843009	; 0x1010101
     a56:	fa00 f00c 	lsl.w	r0, r0, ip
		*p |= (((color & 0x800000) >> 23) | ((color & 0x400000) >> 14) | ((color & 0x200000) >> 5) | ((color & 0x100000) << 4)) << strip;
     a5a:	f3c2 51c0 	ubfx	r1, r2, #23, #1
     a5e:	1395      	asrs	r5, r2, #14
     a60:	f405 7580 	and.w	r5, r5, #256	; 0x100
     a64:	4329      	orrs	r1, r5
     a66:	1155      	asrs	r5, r2, #5
     a68:	f405 3580 	and.w	r5, r5, #65536	; 0x10000
     a6c:	4329      	orrs	r1, r5
     a6e:	0115      	lsls	r5, r2, #4
     a70:	f005 7580 	and.w	r5, r5, #16777216	; 0x1000000
     a74:	4329      	orrs	r1, r5
     a76:	fa01 f10c 	lsl.w	r1, r1, ip
		*p &= ~mask32;
     a7a:	f854 500e 	ldr.w	r5, [r4, lr]
     a7e:	ea25 0500 	bic.w	r5, r5, r0
		*p |= (((color & 0x800000) >> 23) | ((color & 0x400000) >> 14) | ((color & 0x200000) >> 5) | ((color & 0x100000) << 4)) << strip;
     a82:	4329      	orrs	r1, r5
     a84:	f844 100e 	str.w	r1, [r4, lr]
		*p |= (((color & 0x80000) >> 19) | ((color & 0x40000) >> 10) | ((color & 0x20000) >> 1) | ((color & 0x10000) << 8)) << strip;
     a88:	f3c2 41c0 	ubfx	r1, r2, #19, #1
     a8c:	1294      	asrs	r4, r2, #10
     a8e:	f404 7480 	and.w	r4, r4, #256	; 0x100
     a92:	4321      	orrs	r1, r4
     a94:	1054      	asrs	r4, r2, #1
     a96:	f404 3480 	and.w	r4, r4, #65536	; 0x10000
     a9a:	4321      	orrs	r1, r4
     a9c:	0214      	lsls	r4, r2, #8
     a9e:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
     aa2:	4321      	orrs	r1, r4
     aa4:	fa01 f10c 	lsl.w	r1, r1, ip
		*++p &= ~mask32;
     aa8:	685c      	ldr	r4, [r3, #4]
     aaa:	ea24 0400 	bic.w	r4, r4, r0
		*p |= (((color & 0x80000) >> 19) | ((color & 0x40000) >> 10) | ((color & 0x20000) >> 1) | ((color & 0x10000) << 8)) << strip;
     aae:	4321      	orrs	r1, r4
     ab0:	6059      	str	r1, [r3, #4]
		*p |= (((color & 0x8000) >> 15) | ((color & 0x4000) >> 6) | ((color & 0x2000) << 3) | ((color & 0x1000) << 12)) << strip;
     ab2:	f3c2 31c0 	ubfx	r1, r2, #15, #1
     ab6:	1194      	asrs	r4, r2, #6
     ab8:	f404 7480 	and.w	r4, r4, #256	; 0x100
     abc:	4321      	orrs	r1, r4
     abe:	00d4      	lsls	r4, r2, #3
     ac0:	f404 3480 	and.w	r4, r4, #65536	; 0x10000
     ac4:	4321      	orrs	r1, r4
     ac6:	0314      	lsls	r4, r2, #12
     ac8:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
     acc:	4321      	orrs	r1, r4
     ace:	fa01 f10c 	lsl.w	r1, r1, ip
		*++p &= ~mask32;
     ad2:	689c      	ldr	r4, [r3, #8]
     ad4:	ea24 0400 	bic.w	r4, r4, r0
		*p |= (((color & 0x8000) >> 15) | ((color & 0x4000) >> 6) | ((color & 0x2000) << 3) | ((color & 0x1000) << 12)) << strip;
     ad8:	4321      	orrs	r1, r4
     ada:	6099      	str	r1, [r3, #8]
		*p |= (((color & 0x800) >> 11) | ((color & 0x400) >> 2) | ((color & 0x200) << 7) | ((color & 0x100) << 16)) << strip;
     adc:	f3c2 21c0 	ubfx	r1, r2, #11, #1
     ae0:	1094      	asrs	r4, r2, #2
     ae2:	f404 7480 	and.w	r4, r4, #256	; 0x100
     ae6:	4321      	orrs	r1, r4
     ae8:	01d4      	lsls	r4, r2, #7
     aea:	f404 3480 	and.w	r4, r4, #65536	; 0x10000
     aee:	4321      	orrs	r1, r4
     af0:	0414      	lsls	r4, r2, #16
     af2:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
     af6:	4321      	orrs	r1, r4
     af8:	fa01 f10c 	lsl.w	r1, r1, ip
		*++p &= ~mask32;
     afc:	68dc      	ldr	r4, [r3, #12]
     afe:	ea24 0400 	bic.w	r4, r4, r0
		*p |= (((color & 0x800) >> 11) | ((color & 0x400) >> 2) | ((color & 0x200) << 7) | ((color & 0x100) << 16)) << strip;
     b02:	4321      	orrs	r1, r4
     b04:	60d9      	str	r1, [r3, #12]
		*p |= (((color & 0x80) >> 7) | ((color & 0x40) << 2) | ((color & 0x20) << 11) | ((color & 0x10) << 20)) << strip;
     b06:	f3c2 11c0 	ubfx	r1, r2, #7, #1
     b0a:	0094      	lsls	r4, r2, #2
     b0c:	f404 7480 	and.w	r4, r4, #256	; 0x100
     b10:	4321      	orrs	r1, r4
     b12:	02d4      	lsls	r4, r2, #11
     b14:	f404 3480 	and.w	r4, r4, #65536	; 0x10000
     b18:	4321      	orrs	r1, r4
     b1a:	0514      	lsls	r4, r2, #20
     b1c:	f004 7480 	and.w	r4, r4, #16777216	; 0x1000000
     b20:	4321      	orrs	r1, r4
     b22:	fa01 f10c 	lsl.w	r1, r1, ip
		*++p &= ~mask32;
     b26:	691c      	ldr	r4, [r3, #16]
     b28:	ea24 0400 	bic.w	r4, r4, r0
		*p |= (((color & 0x80) >> 7) | ((color & 0x40) << 2) | ((color & 0x20) << 11) | ((color & 0x10) << 20)) << strip;
     b2c:	4321      	orrs	r1, r4
     b2e:	6119      	str	r1, [r3, #16]
		*p |= (((color & 0x8) >> 3) | ((color & 0x4) << 6) | ((color & 0x2) << 15) | ((color & 0x1) << 24)) << strip;
     b30:	f3c2 01c0 	ubfx	r1, r2, #3, #1
     b34:	0194      	lsls	r4, r2, #6
     b36:	f404 7480 	and.w	r4, r4, #256	; 0x100
     b3a:	4321      	orrs	r1, r4
     b3c:	03d4      	lsls	r4, r2, #15
     b3e:	f404 3480 	and.w	r4, r4, #65536	; 0x10000
     b42:	4321      	orrs	r1, r4
     b44:	0612      	lsls	r2, r2, #24
     b46:	f002 7280 	and.w	r2, r2, #16777216	; 0x1000000
     b4a:	430a      	orrs	r2, r1
     b4c:	fa02 f20c 	lsl.w	r2, r2, ip
		*++p &= ~mask32;
     b50:	6959      	ldr	r1, [r3, #20]
     b52:	ea21 0100 	bic.w	r1, r1, r0
		*p |= (((color & 0x8) >> 3) | ((color & 0x4) << 6) | ((color & 0x2) << 15) | ((color & 0x1) << 24)) << strip;
     b56:	430a      	orrs	r2, r1
     b58:	615a      	str	r2, [r3, #20]
}
     b5a:	bd30      	pop	{r4, r5, pc}
			color = ((color<<8)&0xFF0000) | ((color>>8)&0x00FF00) | (color&0x0000FF);
     b5c:	0213      	lsls	r3, r2, #8
     b5e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
     b62:	1210      	asrs	r0, r2, #8
     b64:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
     b68:	4303      	orrs	r3, r0
     b6a:	b2d2      	uxtb	r2, r2
     b6c:	431a      	orrs	r2, r3
			break;
     b6e:	e762      	b.n	a36 <OctoWS2811::setPixel(unsigned long, int)+0x36>
			color = ((color<<16)&0xFF0000) | ((color>>8)&0x00FFFF);
     b70:	0413      	lsls	r3, r2, #16
     b72:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
     b76:	f3c2 220f 	ubfx	r2, r2, #8, #16
     b7a:	431a      	orrs	r2, r3
			break;
     b7c:	e75b      	b.n	a36 <OctoWS2811::setPixel(unsigned long, int)+0x36>
			color = ((color<<8)&0xFFFF00) | ((color>>16)&0x0000FF);
     b7e:	0213      	lsls	r3, r2, #8
     b80:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     b84:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
     b88:	f3c2 4207 	ubfx	r2, r2, #16, #8
     b8c:	431a      	orrs	r2, r3
			break;
     b8e:	e752      	b.n	a36 <OctoWS2811::setPixel(unsigned long, int)+0x36>
			color = ((color<<16)&0xFF0000) | (color&0x00FF00) | ((color>>16)&0x0000FF);
     b90:	f402 407f 	and.w	r0, r2, #65280	; 0xff00
     b94:	0413      	lsls	r3, r2, #16
     b96:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
     b9a:	f3c2 4207 	ubfx	r2, r2, #16, #8
     b9e:	4313      	orrs	r3, r2
     ba0:	ea40 0203 	orr.w	r2, r0, r3
			break;
     ba4:	e747      	b.n	a36 <OctoWS2811::setPixel(unsigned long, int)+0x36>
		uint8_t g = color >> 8;
     ba6:	1214      	asrs	r4, r2, #8
		uint8_t r = color >> 16;
     ba8:	1413      	asrs	r3, r2, #16
		switch (params & 0x1F) {
     baa:	3806      	subs	r0, #6
     bac:	2817      	cmp	r0, #23
     bae:	f200 81f6 	bhi.w	f9e <OctoWS2811::setPixel(unsigned long, int)+0x59e>
     bb2:	e8df f010 	tbh	[pc, r0, lsl #1]
     bb6:	001f      	.short	0x001f
     bb8:	0119010e 	.word	0x0119010e
     bbc:	012e0123 	.word	0x012e0123
     bc0:	00290138 	.word	0x00290138
     bc4:	014a0142 	.word	0x014a0142
     bc8:	01630156 	.word	0x01630156
     bcc:	0178016f 	.word	0x0178016f
     bd0:	0189017f 	.word	0x0189017f
     bd4:	019d0193 	.word	0x019d0193
     bd8:	01b101a7 	.word	0x01b101a7
     bdc:	01c701bc 	.word	0x01c701bc
     be0:	01df01cf 	.word	0x01df01cf
     be4:	01e9      	.short	0x01e9
     be6:	bf00      	nop
     be8:	1fff8b64 	.word	0x1fff8b64
     bec:	1fff8b66 	.word	0x1fff8b66
     bf0:	1fff8b44 	.word	0x1fff8b44
			case WS2811_RGBW: c = (r << 24) | (g << 16) | (b << 8) | w; break;
     bf4:	0210      	lsls	r0, r2, #8
     bf6:	b280      	uxth	r0, r0
     bf8:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
     bfc:	0424      	lsls	r4, r4, #16
     bfe:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
     c02:	4323      	orrs	r3, r4
     c04:	ea43 6212 	orr.w	r2, r3, r2, lsr #24
		uint32_t strip = num / stripLen;
     c08:	4bd8      	ldr	r3, [pc, #864]	; (f6c <OctoWS2811::setPixel(unsigned long, int)+0x56c>)
     c0a:	881b      	ldrh	r3, [r3, #0]
     c0c:	fbb1 fcf3 	udiv	ip, r1, r3
		uint32_t offset = num % stripLen;
     c10:	fb03 111c 	mls	r1, r3, ip, r1
		uint32_t *p = ((uint32_t *) drawBuffer) + offset * 8;
     c14:	ea4f 1e41 	mov.w	lr, r1, lsl #5
     c18:	4bd5      	ldr	r3, [pc, #852]	; (f70 <OctoWS2811::setPixel(unsigned long, int)+0x570>)
     c1a:	681c      	ldr	r4, [r3, #0]
     c1c:	eb04 1141 	add.w	r1, r4, r1, lsl #5
		uint32_t mask32 = (0x01010101) << strip;
     c20:	f04f 3001 	mov.w	r0, #16843009	; 0x1010101
     c24:	fa00 f00c 	lsl.w	r0, r0, ip
		*p |= (((c & 0x80000000) >> 31) | ((c & 0x40000000) >> 22) | ((c & 0x20000000) >> 13) | ((c & 0x10000000) >> 4)) << strip;
     c28:	0d93      	lsrs	r3, r2, #22
     c2a:	f403 7380 	and.w	r3, r3, #256	; 0x100
     c2e:	0b55      	lsrs	r5, r2, #13
     c30:	f405 3580 	and.w	r5, r5, #65536	; 0x10000
     c34:	432b      	orrs	r3, r5
     c36:	ea43 73d2 	orr.w	r3, r3, r2, lsr #31
     c3a:	0915      	lsrs	r5, r2, #4
     c3c:	f005 7580 	and.w	r5, r5, #16777216	; 0x1000000
     c40:	432b      	orrs	r3, r5
     c42:	fa03 f30c 	lsl.w	r3, r3, ip
		*p &= ~mask32;
     c46:	f854 500e 	ldr.w	r5, [r4, lr]
     c4a:	ea25 0500 	bic.w	r5, r5, r0
		*p |= (((c & 0x80000000) >> 31) | ((c & 0x40000000) >> 22) | ((c & 0x20000000) >> 13) | ((c & 0x10000000) >> 4)) << strip;
     c4e:	432b      	orrs	r3, r5
     c50:	f844 300e 	str.w	r3, [r4, lr]
		*p |= (((c & 0x8000000) >> 27) | ((c & 0x4000000) >> 18) | ((c & 0x2000000) >> 9) | ((c & 0x1000000) << 0)) << strip;
     c54:	f3c2 63c0 	ubfx	r3, r2, #27, #1
     c58:	ea4f 4e92 	mov.w	lr, r2, lsr #18
     c5c:	f40e 7e80 	and.w	lr, lr, #256	; 0x100
     c60:	ea43 030e 	orr.w	r3, r3, lr
     c64:	f002 7480 	and.w	r4, r2, #16777216	; 0x1000000
     c68:	4323      	orrs	r3, r4
     c6a:	ea4f 2e52 	mov.w	lr, r2, lsr #9
     c6e:	f40e 3e80 	and.w	lr, lr, #65536	; 0x10000
     c72:	ea43 030e 	orr.w	r3, r3, lr
     c76:	fa03 f30c 	lsl.w	r3, r3, ip
		*++p &= ~mask32;
     c7a:	684c      	ldr	r4, [r1, #4]
     c7c:	ea24 0e00 	bic.w	lr, r4, r0
		*p |= (((c & 0x8000000) >> 27) | ((c & 0x4000000) >> 18) | ((c & 0x2000000) >> 9) | ((c & 0x1000000) << 0)) << strip;
     c80:	ea43 030e 	orr.w	r3, r3, lr
     c84:	604b      	str	r3, [r1, #4]
		*p |= (((c & 0x800000) >> 23) | ((c & 0x400000) >> 14) | ((c & 0x200000) >> 5) | ((c & 0x100000) << 4)) << strip;
     c86:	f3c2 53c0 	ubfx	r3, r2, #23, #1
     c8a:	ea4f 3e92 	mov.w	lr, r2, lsr #14
     c8e:	f40e 7e80 	and.w	lr, lr, #256	; 0x100
     c92:	ea43 030e 	orr.w	r3, r3, lr
     c96:	ea4f 1e52 	mov.w	lr, r2, lsr #5
     c9a:	f40e 3e80 	and.w	lr, lr, #65536	; 0x10000
     c9e:	ea43 030e 	orr.w	r3, r3, lr
     ca2:	ea4f 1e02 	mov.w	lr, r2, lsl #4
     ca6:	f00e 7e80 	and.w	lr, lr, #16777216	; 0x1000000
     caa:	ea43 030e 	orr.w	r3, r3, lr
     cae:	fa03 f30c 	lsl.w	r3, r3, ip
		*++p &= ~mask32;
     cb2:	688c      	ldr	r4, [r1, #8]
     cb4:	ea24 0e00 	bic.w	lr, r4, r0
		*p |= (((c & 0x800000) >> 23) | ((c & 0x400000) >> 14) | ((c & 0x200000) >> 5) | ((c & 0x100000) << 4)) << strip;
     cb8:	ea43 030e 	orr.w	r3, r3, lr
     cbc:	608b      	str	r3, [r1, #8]
		*p |= (((c & 0x80000) >> 19) | ((c & 0x40000) >> 10) | ((c & 0x20000) >> 1) | ((c & 0x10000) << 8)) << strip;
     cbe:	f3c2 43c0 	ubfx	r3, r2, #19, #1
     cc2:	ea4f 2e92 	mov.w	lr, r2, lsr #10
     cc6:	f40e 7e80 	and.w	lr, lr, #256	; 0x100
     cca:	ea43 030e 	orr.w	r3, r3, lr
     cce:	ea4f 0e52 	mov.w	lr, r2, lsr #1
     cd2:	f40e 3e80 	and.w	lr, lr, #65536	; 0x10000
     cd6:	ea43 030e 	orr.w	r3, r3, lr
     cda:	ea4f 2e02 	mov.w	lr, r2, lsl #8
     cde:	f00e 7e80 	and.w	lr, lr, #16777216	; 0x1000000
     ce2:	ea43 030e 	orr.w	r3, r3, lr
     ce6:	fa03 f30c 	lsl.w	r3, r3, ip
		*++p &= ~mask32;
     cea:	68cc      	ldr	r4, [r1, #12]
     cec:	ea24 0e00 	bic.w	lr, r4, r0
		*p |= (((c & 0x80000) >> 19) | ((c & 0x40000) >> 10) | ((c & 0x20000) >> 1) | ((c & 0x10000) << 8)) << strip;
     cf0:	ea43 030e 	orr.w	r3, r3, lr
     cf4:	60cb      	str	r3, [r1, #12]
		*p |= (((c & 0x8000) >> 15) | ((c & 0x4000) >> 6) | ((c & 0x2000) << 3) | ((c & 0x1000) << 12)) << strip;
     cf6:	f3c2 33c0 	ubfx	r3, r2, #15, #1
     cfa:	ea4f 1e92 	mov.w	lr, r2, lsr #6
     cfe:	f40e 7e80 	and.w	lr, lr, #256	; 0x100
     d02:	ea43 030e 	orr.w	r3, r3, lr
     d06:	ea4f 0ec2 	mov.w	lr, r2, lsl #3
     d0a:	f40e 3e80 	and.w	lr, lr, #65536	; 0x10000
     d0e:	ea43 030e 	orr.w	r3, r3, lr
     d12:	ea4f 3e02 	mov.w	lr, r2, lsl #12
     d16:	f00e 7e80 	and.w	lr, lr, #16777216	; 0x1000000
     d1a:	ea43 030e 	orr.w	r3, r3, lr
     d1e:	fa03 f30c 	lsl.w	r3, r3, ip
		*++p &= ~mask32;
     d22:	690c      	ldr	r4, [r1, #16]
     d24:	ea24 0e00 	bic.w	lr, r4, r0
		*p |= (((c & 0x8000) >> 15) | ((c & 0x4000) >> 6) | ((c & 0x2000) << 3) | ((c & 0x1000) << 12)) << strip;
     d28:	ea43 030e 	orr.w	r3, r3, lr
     d2c:	610b      	str	r3, [r1, #16]
		*p |= (((c & 0x800) >> 11) | ((c & 0x400) >> 2) | ((c & 0x200) << 7) | ((c & 0x100) << 16)) << strip;
     d2e:	f3c2 23c0 	ubfx	r3, r2, #11, #1
     d32:	ea4f 0e92 	mov.w	lr, r2, lsr #2
     d36:	f40e 7e80 	and.w	lr, lr, #256	; 0x100
     d3a:	ea43 030e 	orr.w	r3, r3, lr
     d3e:	ea4f 1ec2 	mov.w	lr, r2, lsl #7
     d42:	f40e 3e80 	and.w	lr, lr, #65536	; 0x10000
     d46:	ea43 030e 	orr.w	r3, r3, lr
     d4a:	ea4f 4e02 	mov.w	lr, r2, lsl #16
     d4e:	f00e 7e80 	and.w	lr, lr, #16777216	; 0x1000000
     d52:	ea43 030e 	orr.w	r3, r3, lr
     d56:	fa03 f30c 	lsl.w	r3, r3, ip
		*++p &= ~mask32;
     d5a:	694c      	ldr	r4, [r1, #20]
     d5c:	ea24 0e00 	bic.w	lr, r4, r0
		*p |= (((c & 0x800) >> 11) | ((c & 0x400) >> 2) | ((c & 0x200) << 7) | ((c & 0x100) << 16)) << strip;
     d60:	ea43 030e 	orr.w	r3, r3, lr
     d64:	614b      	str	r3, [r1, #20]
		*p |= (((c & 0x80) >> 7) | ((c & 0x40) << 2) | ((c & 0x20) << 11) | ((c & 0x10) << 20)) << strip;
     d66:	f3c2 13c0 	ubfx	r3, r2, #7, #1
     d6a:	ea4f 0e82 	mov.w	lr, r2, lsl #2
     d6e:	f40e 7e80 	and.w	lr, lr, #256	; 0x100
     d72:	ea43 030e 	orr.w	r3, r3, lr
     d76:	ea4f 2ec2 	mov.w	lr, r2, lsl #11
     d7a:	f40e 3e80 	and.w	lr, lr, #65536	; 0x10000
     d7e:	ea43 030e 	orr.w	r3, r3, lr
     d82:	ea4f 5e02 	mov.w	lr, r2, lsl #20
     d86:	f00e 7e80 	and.w	lr, lr, #16777216	; 0x1000000
     d8a:	ea43 030e 	orr.w	r3, r3, lr
     d8e:	fa03 f30c 	lsl.w	r3, r3, ip
		*++p &= ~mask32;
     d92:	698c      	ldr	r4, [r1, #24]
     d94:	ea24 0e00 	bic.w	lr, r4, r0
		*p |= (((c & 0x80) >> 7) | ((c & 0x40) << 2) | ((c & 0x20) << 11) | ((c & 0x10) << 20)) << strip;
     d98:	ea43 030e 	orr.w	r3, r3, lr
     d9c:	618b      	str	r3, [r1, #24]
		*p |= (((c & 0x8) >> 3) | ((c & 0x4) << 6) | ((c & 0x2) << 15) | ((c & 0x1) << 24)) << strip;
     d9e:	f3c2 03c0 	ubfx	r3, r2, #3, #1
     da2:	ea4f 1e82 	mov.w	lr, r2, lsl #6
     da6:	f40e 7e80 	and.w	lr, lr, #256	; 0x100
     daa:	ea43 030e 	orr.w	r3, r3, lr
     dae:	ea4f 3ec2 	mov.w	lr, r2, lsl #15
     db2:	f40e 3e80 	and.w	lr, lr, #65536	; 0x10000
     db6:	ea43 030e 	orr.w	r3, r3, lr
     dba:	0612      	lsls	r2, r2, #24
     dbc:	f002 7280 	and.w	r2, r2, #16777216	; 0x1000000
     dc0:	4313      	orrs	r3, r2
     dc2:	fa03 f30c 	lsl.w	r3, r3, ip
		*++p &= ~mask32;
     dc6:	69ca      	ldr	r2, [r1, #28]
     dc8:	ea22 0200 	bic.w	r2, r2, r0
		*p |= (((c & 0x8) >> 3) | ((c & 0x4) << 6) | ((c & 0x2) << 15) | ((c & 0x1) << 24)) << strip;
     dcc:	4313      	orrs	r3, r2
     dce:	61cb      	str	r3, [r1, #28]
}
     dd0:	e6c3      	b.n	b5a <OctoWS2811::setPixel(unsigned long, int)+0x15a>
			case WS2811_RBGW: c = (r << 24) | (b << 16) | (g << 8) | w; break;
     dd2:	0410      	lsls	r0, r2, #16
     dd4:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
     dd8:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
     ddc:	f402 407f 	and.w	r0, r2, #65280	; 0xff00
     de0:	4303      	orrs	r3, r0
     de2:	ea43 6212 	orr.w	r2, r3, r2, lsr #24
     de6:	e70f      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_GRBW: c = (g << 24) | (r << 16) | (b << 8) | w; break;
     de8:	0213      	lsls	r3, r2, #8
     dea:	b29b      	uxth	r3, r3
     dec:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
     df0:	f402 007f 	and.w	r0, r2, #16711680	; 0xff0000
     df4:	4303      	orrs	r3, r0
     df6:	ea43 6212 	orr.w	r2, r3, r2, lsr #24
     dfa:	e705      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_GBRW: c = (g << 24) | (b << 16) | (r << 8) | w; break;
     dfc:	0410      	lsls	r0, r2, #16
     dfe:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
     e02:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
     e06:	021b      	lsls	r3, r3, #8
     e08:	b29b      	uxth	r3, r3
     e0a:	4303      	orrs	r3, r0
     e0c:	ea43 6212 	orr.w	r2, r3, r2, lsr #24
     e10:	e6fa      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_BRGW: c = (b << 24) | (r << 16) | (g << 8) | w; break;
     e12:	f402 037f 	and.w	r3, r2, #16711680	; 0xff0000
     e16:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     e1a:	f402 407f 	and.w	r0, r2, #65280	; 0xff00
     e1e:	4303      	orrs	r3, r0
     e20:	ea43 6212 	orr.w	r2, r3, r2, lsr #24
     e24:	e6f0      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_BGRW: c = (b << 24) | (b << 16) | (r << 8) | w; break;
     e26:	b2d0      	uxtb	r0, r2
     e28:	0400      	lsls	r0, r0, #16
     e2a:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
     e2e:	021b      	lsls	r3, r3, #8
     e30:	b29b      	uxth	r3, r3
     e32:	4303      	orrs	r3, r0
     e34:	ea43 6212 	orr.w	r2, r3, r2, lsr #24
     e38:	e6e6      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_WRBG: c = (w << 24) | (r << 16) | (b << 8) | g; break;
     e3a:	0213      	lsls	r3, r2, #8
     e3c:	b29b      	uxth	r3, r3
     e3e:	b2e4      	uxtb	r4, r4
     e40:	4323      	orrs	r3, r4
     e42:	0c12      	lsrs	r2, r2, #16
     e44:	0412      	lsls	r2, r2, #16
     e46:	431a      	orrs	r2, r3
     e48:	e6de      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_WGRB: c = (w << 24) | (g << 16) | (r << 8) | b; break;
     e4a:	0424      	lsls	r4, r4, #16
     e4c:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
     e50:	021b      	lsls	r3, r3, #8
     e52:	b29b      	uxth	r3, r3
     e54:	4323      	orrs	r3, r4
     e56:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
     e5a:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
     e5e:	431a      	orrs	r2, r3
     e60:	e6d2      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_WGBR: c = (w << 24) | (g << 16) | (b << 8) | r; break;
     e62:	0210      	lsls	r0, r2, #8
     e64:	b280      	uxth	r0, r0
     e66:	b2db      	uxtb	r3, r3
     e68:	4303      	orrs	r3, r0
     e6a:	f002 427f 	and.w	r2, r2, #4278190080	; 0xff000000
     e6e:	4313      	orrs	r3, r2
     e70:	0424      	lsls	r4, r4, #16
     e72:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
     e76:	ea43 0204 	orr.w	r2, r3, r4
     e7a:	e6c5      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_WBRG: c = (w << 24) | (b << 16) | (r << 8) | g; break;
     e7c:	0410      	lsls	r0, r2, #16
     e7e:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
     e82:	b2e4      	uxtb	r4, r4
     e84:	4320      	orrs	r0, r4
     e86:	f002 427f 	and.w	r2, r2, #4278190080	; 0xff000000
     e8a:	4302      	orrs	r2, r0
     e8c:	021b      	lsls	r3, r3, #8
     e8e:	b29b      	uxth	r3, r3
     e90:	431a      	orrs	r2, r3
     e92:	e6b9      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_WBGR: c = (w << 24) | (b << 16) | (g << 8) | r; break;
     e94:	0410      	lsls	r0, r2, #16
     e96:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
     e9a:	b2db      	uxtb	r3, r3
     e9c:	4303      	orrs	r3, r0
     e9e:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
     ea2:	431a      	orrs	r2, r3
     ea4:	e6b0      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_RWGB: c = (r << 24) | (w << 16) | (g << 8) | b; break;
     ea6:	b290      	uxth	r0, r2
     ea8:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
     eac:	0e12      	lsrs	r2, r2, #24
     eae:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     eb2:	e6a9      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_RWBG: c = (r << 24) | (w << 16) | (b << 8) | g; break;
     eb4:	0210      	lsls	r0, r2, #8
     eb6:	b280      	uxth	r0, r0
     eb8:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
     ebc:	b2e4      	uxtb	r4, r4
     ebe:	4323      	orrs	r3, r4
     ec0:	0e12      	lsrs	r2, r2, #24
     ec2:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     ec6:	e69f      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_GWRB: c = (g << 24) | (w << 16) | (r << 8) | b; break;
     ec8:	b2d0      	uxtb	r0, r2
     eca:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
     ece:	021b      	lsls	r3, r3, #8
     ed0:	b29b      	uxth	r3, r3
     ed2:	4303      	orrs	r3, r0
     ed4:	0e12      	lsrs	r2, r2, #24
     ed6:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     eda:	e695      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_GWBR: c = (g << 24) | (w << 16) | (b << 8) | r; break;
     edc:	0210      	lsls	r0, r2, #8
     ede:	b280      	uxth	r0, r0
     ee0:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
     ee4:	b2db      	uxtb	r3, r3
     ee6:	4303      	orrs	r3, r0
     ee8:	0e12      	lsrs	r2, r2, #24
     eea:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     eee:	e68b      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_BWRG: c = (b << 24) | (w << 16) | (r << 8) | g; break;
     ef0:	b2e4      	uxtb	r4, r4
     ef2:	ea44 6402 	orr.w	r4, r4, r2, lsl #24
     ef6:	021b      	lsls	r3, r3, #8
     ef8:	b29b      	uxth	r3, r3
     efa:	4323      	orrs	r3, r4
     efc:	0e12      	lsrs	r2, r2, #24
     efe:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     f02:	e681      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_BWGR: c = (b << 24) | (w << 16) | (g << 8) | r; break;
     f04:	f402 407f 	and.w	r0, r2, #65280	; 0xff00
     f08:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
     f0c:	b2db      	uxtb	r3, r3
     f0e:	4303      	orrs	r3, r0
     f10:	0e12      	lsrs	r2, r2, #24
     f12:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     f16:	e677      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_RGWB: c = (r << 24) | (g << 16) | (w << 8) | b; break;
     f18:	b2d0      	uxtb	r0, r2
     f1a:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
     f1e:	0424      	lsls	r4, r4, #16
     f20:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
     f24:	4323      	orrs	r3, r4
     f26:	0e12      	lsrs	r2, r2, #24
     f28:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
     f2c:	e66c      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_RBWG: c = (r << 24) | (b << 16) | (w << 8) | g; break;
     f2e:	0410      	lsls	r0, r2, #16
     f30:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
     f34:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
     f38:	b2e4      	uxtb	r4, r4
     f3a:	4323      	orrs	r3, r4
     f3c:	0e12      	lsrs	r2, r2, #24
     f3e:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
     f42:	e661      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_GRWB: c = (g << 24) | (r << 16) | (w << 8) | b; break;
     f44:	f002 13ff 	and.w	r3, r2, #16711935	; 0xff00ff
     f48:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
     f4c:	0e12      	lsrs	r2, r2, #24
     f4e:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
     f52:	e659      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_GBWR: c = (g << 24) | (b << 16) | (w << 8) | r; break;
     f54:	0410      	lsls	r0, r2, #16
     f56:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
     f5a:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
     f5e:	b2db      	uxtb	r3, r3
     f60:	4303      	orrs	r3, r0
     f62:	0e12      	lsrs	r2, r2, #24
     f64:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
     f68:	e64e      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
     f6a:	bf00      	nop
     f6c:	1fff8b66 	.word	0x1fff8b66
     f70:	1fff8b44 	.word	0x1fff8b44
			case WS2811_BRWG: c = (b << 24) | (r << 16) | (w << 8) | g; break;
     f74:	f402 037f 	and.w	r3, r2, #16711680	; 0xff0000
     f78:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     f7c:	b2e4      	uxtb	r4, r4
     f7e:	4323      	orrs	r3, r4
     f80:	0e12      	lsrs	r2, r2, #24
     f82:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
     f86:	e63f      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
			case WS2811_BGWR: c = (b << 24) | (g << 16) | (w << 8) | r; break;
     f88:	b2db      	uxtb	r3, r3
     f8a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     f8e:	0424      	lsls	r4, r4, #16
     f90:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
     f94:	4323      	orrs	r3, r4
     f96:	0e12      	lsrs	r2, r2, #24
     f98:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
     f9c:	e634      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
		switch (params & 0x1F) {
     f9e:	2200      	movs	r2, #0
     fa0:	e632      	b.n	c08 <OctoWS2811::setPixel(unsigned long, int)+0x208>
     fa2:	bf00      	nop

00000fa4 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE>:
}
     fa4:	b570      	push	{r4, r5, r6, lr}
		begin();
     fa6:	4e10      	ldr	r6, [pc, #64]	; (fe8 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x44>)
     fa8:	2100      	movs	r1, #0
     faa:	4630      	mov	r0, r6
     fac:	f000 f838 	bl	1020 <DMAChannel::begin(bool)>
DMAChannel OctoWS2811::dma1;
     fb0:	4d0e      	ldr	r5, [pc, #56]	; (fec <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x48>)
     fb2:	4c0f      	ldr	r4, [pc, #60]	; (ff0 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x4c>)
     fb4:	462a      	mov	r2, r5
     fb6:	4621      	mov	r1, r4
     fb8:	4630      	mov	r0, r6
     fba:	f001 fb89 	bl	26d0 <__aeabi_atexit>
     fbe:	4e0d      	ldr	r6, [pc, #52]	; (ff4 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x50>)
     fc0:	2100      	movs	r1, #0
     fc2:	4630      	mov	r0, r6
     fc4:	f000 f82c 	bl	1020 <DMAChannel::begin(bool)>
DMAChannel OctoWS2811::dma2;
     fc8:	462a      	mov	r2, r5
     fca:	4621      	mov	r1, r4
     fcc:	4630      	mov	r0, r6
     fce:	f001 fb7f 	bl	26d0 <__aeabi_atexit>
     fd2:	4e09      	ldr	r6, [pc, #36]	; (ff8 <_GLOBAL__sub_I__ZN10OctoWS28118stripLenE+0x54>)
     fd4:	2100      	movs	r1, #0
     fd6:	4630      	mov	r0, r6
     fd8:	f000 f822 	bl	1020 <DMAChannel::begin(bool)>
DMAChannel OctoWS2811::dma3;
     fdc:	462a      	mov	r2, r5
     fde:	4621      	mov	r1, r4
     fe0:	4630      	mov	r0, r6
     fe2:	f001 fb75 	bl	26d0 <__aeabi_atexit>
}
     fe6:	bd70      	pop	{r4, r5, r6, pc}
     fe8:	1fff8b4c 	.word	0x1fff8b4c
     fec:	1fff891c 	.word	0x1fff891c
     ff0:	0000063d 	.word	0x0000063d
     ff4:	1fff8b54 	.word	0x1fff8b54
     ff8:	1fff8b5c 	.word	0x1fff8b5c

00000ffc <priority(DMAChannel const&)>:
}

static uint32_t priority(const DMAChannel &c)
{
	uint32_t n;
	n = *(uint32_t *)((uint32_t)&DMA_DCHPRI3 + (c.channel & 0xFC));
     ffc:	7903      	ldrb	r3, [r0, #4]
     ffe:	f003 02fc 	and.w	r2, r3, #252	; 0xfc
    1002:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    1006:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
    100a:	f8d2 0100 	ldr.w	r0, [r2, #256]	; 0x100
	n = __builtin_bswap32(n);
    100e:	ba00      	rev	r0, r0
	return (n >> ((c.channel & 0x03) << 3)) & 0x0F;
    1010:	00db      	lsls	r3, r3, #3
    1012:	f003 0318 	and.w	r3, r3, #24
    1016:	40d8      	lsrs	r0, r3
}
    1018:	f000 000f 	and.w	r0, r0, #15
    101c:	4770      	bx	lr
    101e:	Address 0x000000000000101e is out of bounds.


00001020 <DMAChannel::begin(bool)>:
	__disable_irq();
    1020:	b672      	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    1022:	b989      	cbnz	r1, 1048 <DMAChannel::begin(bool)+0x28>
    1024:	6802      	ldr	r2, [r0, #0]
    1026:	b17a      	cbz	r2, 1048 <DMAChannel::begin(bool)+0x28>
    1028:	7903      	ldrb	r3, [r0, #4]
    102a:	2b0f      	cmp	r3, #15
    102c:	d80c      	bhi.n	1048 <DMAChannel::begin(bool)+0x28>
	  && (dma_channel_allocated_mask & (1 << channel))
    102e:	4925      	ldr	r1, [pc, #148]	; (10c4 <DMAChannel::begin(bool)+0xa4>)
    1030:	8809      	ldrh	r1, [r1, #0]
    1032:	4119      	asrs	r1, r3
    1034:	f011 0f01 	tst.w	r1, #1
    1038:	d006      	beq.n	1048 <DMAChannel::begin(bool)+0x28>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    103a:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    103e:	f503 6390 	add.w	r3, r3, #1152	; 0x480
    1042:	ebb2 1f43 	cmp.w	r2, r3, lsl #5
    1046:	d010      	beq.n	106a <DMAChannel::begin(bool)+0x4a>
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    1048:	4b1e      	ldr	r3, [pc, #120]	; (10c4 <DMAChannel::begin(bool)+0xa4>)
    104a:	8819      	ldrh	r1, [r3, #0]
    104c:	2300      	movs	r3, #0
    104e:	fa41 f203 	asr.w	r2, r1, r3
    1052:	f012 0f01 	tst.w	r2, #1
    1056:	d00a      	beq.n	106e <DMAChannel::begin(bool)+0x4e>
		if (++ch >= DMA_MAX_CHANNELS) {
    1058:	3301      	adds	r3, #1
    105a:	2b10      	cmp	r3, #16
    105c:	d1f7      	bne.n	104e <DMAChannel::begin(bool)+0x2e>
			__enable_irq();
    105e:	b662      	cpsie	i
			TCD = (TCD_t *)0;
    1060:	2300      	movs	r3, #0
    1062:	6003      	str	r3, [r0, #0]
			channel = DMA_MAX_CHANNELS;
    1064:	2310      	movs	r3, #16
    1066:	7103      	strb	r3, [r0, #4]
			return; // no more channels available
    1068:	4770      	bx	lr
		__enable_irq();
    106a:	b662      	cpsie	i
		return;
    106c:	4770      	bx	lr
{
    106e:	b410      	push	{r4}
			dma_channel_allocated_mask |= (1 << ch);
    1070:	2201      	movs	r2, #1
    1072:	409a      	lsls	r2, r3
    1074:	4311      	orrs	r1, r2
    1076:	4a13      	ldr	r2, [pc, #76]	; (10c4 <DMAChannel::begin(bool)+0xa4>)
    1078:	8011      	strh	r1, [r2, #0]
			__enable_irq();
    107a:	b662      	cpsie	i
	channel = ch;
    107c:	b2d9      	uxtb	r1, r3
    107e:	7101      	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    1080:	4a11      	ldr	r2, [pc, #68]	; (10c8 <DMAChannel::begin(bool)+0xa8>)
    1082:	6c14      	ldr	r4, [r2, #64]	; 0x40
    1084:	f044 0402 	orr.w	r4, r4, #2
    1088:	6414      	str	r4, [r2, #64]	; 0x40
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    108a:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
    108c:	f044 0402 	orr.w	r4, r4, #2
    1090:	63d4      	str	r4, [r2, #60]	; 0x3c
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
    1092:	f5a2 2280 	sub.w	r2, r2, #262144	; 0x40000
    1096:	2482      	movs	r4, #130	; 0x82
    1098:	6014      	str	r4, [r2, #0]
	DMA_CERQ = ch;
    109a:	7691      	strb	r1, [r2, #26]
	DMA_CERR = ch;
    109c:	7791      	strb	r1, [r2, #30]
	DMA_CEEI = ch;
    109e:	7611      	strb	r1, [r2, #24]
	DMA_CINT = ch;
    10a0:	77d1      	strb	r1, [r2, #31]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    10a2:	f103 7300 	add.w	r3, r3, #33554432	; 0x2000000
    10a6:	f503 6390 	add.w	r3, r3, #1152	; 0x480
    10aa:	015b      	lsls	r3, r3, #5
    10ac:	6003      	str	r3, [r0, #0]
	*p++ = 0;
    10ae:	2200      	movs	r2, #0
    10b0:	601a      	str	r2, [r3, #0]
	*p++ = 0;
    10b2:	605a      	str	r2, [r3, #4]
	*p++ = 0;
    10b4:	609a      	str	r2, [r3, #8]
	*p++ = 0;
    10b6:	60da      	str	r2, [r3, #12]
	*p++ = 0;
    10b8:	611a      	str	r2, [r3, #16]
	*p++ = 0;
    10ba:	615a      	str	r2, [r3, #20]
	*p++ = 0;
    10bc:	619a      	str	r2, [r3, #24]
	*p++ = 0;
    10be:	61da      	str	r2, [r3, #28]
}
    10c0:	bc10      	pop	{r4}
    10c2:	4770      	bx	lr
    10c4:	1fff8b68 	.word	0x1fff8b68
    10c8:	40048000 	.word	0x40048000

000010cc <DMAChannel::release()>:
	if (channel >= DMA_MAX_CHANNELS) return;
    10cc:	7903      	ldrb	r3, [r0, #4]
    10ce:	2b0f      	cmp	r3, #15
    10d0:	d80f      	bhi.n	10f2 <DMAChannel::release()+0x26>
	DMA_CERQ = channel;
    10d2:	4a08      	ldr	r2, [pc, #32]	; (10f4 <DMAChannel::release()+0x28>)
    10d4:	7693      	strb	r3, [r2, #26]
	__disable_irq();
    10d6:	b672      	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    10d8:	4907      	ldr	r1, [pc, #28]	; (10f8 <DMAChannel::release()+0x2c>)
    10da:	7903      	ldrb	r3, [r0, #4]
    10dc:	2201      	movs	r2, #1
    10de:	409a      	lsls	r2, r3
    10e0:	880b      	ldrh	r3, [r1, #0]
    10e2:	ea23 0302 	bic.w	r3, r3, r2
    10e6:	800b      	strh	r3, [r1, #0]
	__enable_irq();
    10e8:	b662      	cpsie	i
	channel = DMA_MAX_CHANNELS;
    10ea:	2310      	movs	r3, #16
    10ec:	7103      	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    10ee:	2300      	movs	r3, #0
    10f0:	6003      	str	r3, [r0, #0]
}
    10f2:	4770      	bx	lr
    10f4:	40008000 	.word	0x40008000
    10f8:	1fff8b68 	.word	0x1fff8b68

000010fc <DMAPriorityOrder(DMAChannel&, DMAChannel&, DMAChannel&)>:
{
	if (priority(ch1) < priority(ch2)) swap(ch1, ch2);
}

void DMAPriorityOrder(DMAChannel &ch1, DMAChannel &ch2, DMAChannel &ch3)
{
    10fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    10fe:	4607      	mov	r7, r0
    1100:	460c      	mov	r4, r1
    1102:	4615      	mov	r5, r2
	if (priority(ch2) < priority(ch3)) swap(ch2, ch3);
    1104:	4608      	mov	r0, r1
    1106:	f7ff ff79 	bl	ffc <priority(DMAChannel const&)>
    110a:	4606      	mov	r6, r0
    110c:	4628      	mov	r0, r5
    110e:	f7ff ff75 	bl	ffc <priority(DMAChannel const&)>
    1112:	4286      	cmp	r6, r0
    1114:	d305      	bcc.n	1122 <DMAPriorityOrder(DMAChannel&, DMAChannel&, DMAChannel&)+0x26>
	if (priority(ch1) < priority(ch2)) swap(ch1, ch2);
    1116:	4638      	mov	r0, r7
    1118:	f7ff ff70 	bl	ffc <priority(DMAChannel const&)>
    111c:	4286      	cmp	r6, r0
    111e:	d811      	bhi.n	1144 <DMAPriorityOrder(DMAChannel&, DMAChannel&, DMAChannel&)+0x48>
	if (priority(ch2) < priority(ch3)) swap(ch2, ch3);
}
    1120:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	c = c1.channel;
    1122:	7923      	ldrb	r3, [r4, #4]
	c1.channel = c2.channel;
    1124:	792a      	ldrb	r2, [r5, #4]
    1126:	7122      	strb	r2, [r4, #4]
	c2.channel = c;
    1128:	712b      	strb	r3, [r5, #4]
	t = c1.TCD;
    112a:	6823      	ldr	r3, [r4, #0]
	c1.TCD = c2.TCD;
    112c:	682a      	ldr	r2, [r5, #0]
    112e:	6022      	str	r2, [r4, #0]
	c2.TCD = t;
    1130:	602b      	str	r3, [r5, #0]
	if (priority(ch1) < priority(ch2)) swap(ch1, ch2);
    1132:	4638      	mov	r0, r7
    1134:	f7ff ff62 	bl	ffc <priority(DMAChannel const&)>
    1138:	4606      	mov	r6, r0
    113a:	4620      	mov	r0, r4
    113c:	f7ff ff5e 	bl	ffc <priority(DMAChannel const&)>
    1140:	4286      	cmp	r6, r0
    1142:	d207      	bcs.n	1154 <DMAPriorityOrder(DMAChannel&, DMAChannel&, DMAChannel&)+0x58>
	c = c1.channel;
    1144:	793b      	ldrb	r3, [r7, #4]
	c1.channel = c2.channel;
    1146:	7922      	ldrb	r2, [r4, #4]
    1148:	713a      	strb	r2, [r7, #4]
	c2.channel = c;
    114a:	7123      	strb	r3, [r4, #4]
	t = c1.TCD;
    114c:	683b      	ldr	r3, [r7, #0]
	c1.TCD = c2.TCD;
    114e:	6822      	ldr	r2, [r4, #0]
    1150:	603a      	str	r2, [r7, #0]
	c2.TCD = t;
    1152:	6023      	str	r3, [r4, #0]
	if (priority(ch2) < priority(ch3)) swap(ch2, ch3);
    1154:	4620      	mov	r0, r4
    1156:	f7ff ff51 	bl	ffc <priority(DMAChannel const&)>
    115a:	4606      	mov	r6, r0
    115c:	4628      	mov	r0, r5
    115e:	f7ff ff4d 	bl	ffc <priority(DMAChannel const&)>
    1162:	4286      	cmp	r6, r0
    1164:	d2dc      	bcs.n	1120 <DMAPriorityOrder(DMAChannel&, DMAChannel&, DMAChannel&)+0x24>
	c = c1.channel;
    1166:	7923      	ldrb	r3, [r4, #4]
	c1.channel = c2.channel;
    1168:	792a      	ldrb	r2, [r5, #4]
    116a:	7122      	strb	r2, [r4, #4]
	c2.channel = c;
    116c:	712b      	strb	r3, [r5, #4]
	t = c1.TCD;
    116e:	6823      	ldr	r3, [r4, #0]
	c1.TCD = c2.TCD;
    1170:	682a      	ldr	r2, [r5, #0]
    1172:	6022      	str	r2, [r4, #0]
	c2.TCD = t;
    1174:	602b      	str	r3, [r5, #0]
}
    1176:	e7d3      	b.n	1120 <DMAPriorityOrder(DMAChannel&, DMAChannel&, DMAChannel&)+0x24>

00001178 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    1178:	b500      	push	{lr}
    117a:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
    117c:	f640 230d 	movw	r3, #2573	; 0xa0d
    1180:	f8ad 3004 	strh.w	r3, [sp, #4]
	return write(buf, 2);
    1184:	6803      	ldr	r3, [r0, #0]
    1186:	685b      	ldr	r3, [r3, #4]
    1188:	2202      	movs	r2, #2
    118a:	a901      	add	r1, sp, #4
    118c:	4798      	blx	r3
}
    118e:	b003      	add	sp, #12
    1190:	f85d fb04 	ldr.w	pc, [sp], #4

00001194 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    1194:	b530      	push	{r4, r5, lr}
    1196:	b08b      	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    1198:	b92a      	cbnz	r2, 11a6 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x12>
		return write((uint8_t)n);
    119a:	6803      	ldr	r3, [r0, #0]
    119c:	681b      	ldr	r3, [r3, #0]
    119e:	b2c9      	uxtb	r1, r1
    11a0:	4798      	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    11a2:	b00b      	add	sp, #44	; 0x2c
    11a4:	bd30      	pop	{r4, r5, pc}
    11a6:	4696      	mov	lr, r2
		base = 10;
    11a8:	2a01      	cmp	r2, #1
    11aa:	bf14      	ite	ne
    11ac:	4696      	movne	lr, r2
    11ae:	f04f 0e0a 	moveq.w	lr, #10
	if (n == 0) {
    11b2:	b9b9      	cbnz	r1, 11e4 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x50>
		buf[sizeof(buf) - 1] = '0';
    11b4:	2230      	movs	r2, #48	; 0x30
    11b6:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    11ba:	f04f 0c21 	mov.w	ip, #33	; 0x21
	if (sign) {
    11be:	b14b      	cbz	r3, 11d4 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x40>
		i--;
    11c0:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    11c4:	fa5f fc8c 	uxtb.w	ip, ip
		buf[i] = '-';
    11c8:	f10c 0328 	add.w	r3, ip, #40	; 0x28
    11cc:	446b      	add	r3, sp
    11ce:	222d      	movs	r2, #45	; 0x2d
    11d0:	f803 2c24 	strb.w	r2, [r3, #-36]
	return write(buf + i, sizeof(buf) - i);
    11d4:	6803      	ldr	r3, [r0, #0]
    11d6:	685b      	ldr	r3, [r3, #4]
    11d8:	f1cc 0222 	rsb	r2, ip, #34	; 0x22
    11dc:	a901      	add	r1, sp, #4
    11de:	4461      	add	r1, ip
    11e0:	4798      	blx	r3
    11e2:	e7de      	b.n	11a2 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0xe>
		i = sizeof(buf) - 1;
    11e4:	f04f 0c21 	mov.w	ip, #33	; 0x21
			digit = n % base;
    11e8:	4674      	mov	r4, lr
    11ea:	e004      	b.n	11f6 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x62>
			i--;
    11ec:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    11f0:	fa5f fc8c 	uxtb.w	ip, ip
			n /= base;
    11f4:	4611      	mov	r1, r2
			digit = n % base;
    11f6:	fbb1 f2fe 	udiv	r2, r1, lr
    11fa:	fb0e 1212 	mls	r2, lr, r2, r1
    11fe:	b2d2      	uxtb	r2, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    1200:	2a09      	cmp	r2, #9
    1202:	bf94      	ite	ls
    1204:	3230      	addls	r2, #48	; 0x30
    1206:	3237      	addhi	r2, #55	; 0x37
    1208:	b2d2      	uxtb	r2, r2
    120a:	f10c 0528 	add.w	r5, ip, #40	; 0x28
    120e:	446d      	add	r5, sp
    1210:	f805 2c24 	strb.w	r2, [r5, #-36]
			n /= base;
    1214:	fbb1 f2f4 	udiv	r2, r1, r4
			if (n == 0) break;
    1218:	428c      	cmp	r4, r1
    121a:	d9e7      	bls.n	11ec <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x58>
    121c:	e7cf      	b.n	11be <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x2a>

0000121e <Print::print(long)>:
{
    121e:	b508      	push	{r3, lr}
	if (n < 0) {
    1220:	2900      	cmp	r1, #0
		n = -n;
    1222:	bfba      	itte	lt
    1224:	4249      	neglt	r1, r1
		sign = '-';
    1226:	232d      	movlt	r3, #45	; 0x2d
	uint8_t sign=0;
    1228:	2300      	movge	r3, #0
	return printNumber(n, 10, sign);
    122a:	220a      	movs	r2, #10
    122c:	f7ff ffb2 	bl	1194 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
}
    1230:	bd08      	pop	{r3, pc}

00001232 <Stream::setTimeout(unsigned long)>:
// Public Methods
//////////////////////////////////////////////////////////////

void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
{
  _timeout = timeout;
    1232:	6081      	str	r1, [r0, #8]
}
    1234:	4770      	bx	lr

00001236 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    1236:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    1238:	f7ff f90e 	bl	458 <setup>
	while (1) {
		loop();
    123c:	f7ff f96e 	bl	51c <loop>
		yield();
    1240:	f001 f8e2 	bl	2408 <yield>
	while (1) {
    1244:	e7fa      	b.n	123c <main+0x6>
    1246:	Address 0x0000000000001246 is out of bounds.


00001248 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    1248:	b401      	push	{r0}
#endif
	orr	r3, r1, r0
    124a:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    124e:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    1252:	d16f      	bne.n	1334 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    1254:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    1256:	d341      	bcc.n	12dc <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    1258:	f851 3b04 	ldr.w	r3, [r1], #4
    125c:	f840 3b04 	str.w	r3, [r0], #4
    1260:	f851 3b04 	ldr.w	r3, [r1], #4
    1264:	f840 3b04 	str.w	r3, [r0], #4
    1268:	f851 3b04 	ldr.w	r3, [r1], #4
    126c:	f840 3b04 	str.w	r3, [r0], #4
    1270:	f851 3b04 	ldr.w	r3, [r1], #4
    1274:	f840 3b04 	str.w	r3, [r0], #4
    1278:	f851 3b04 	ldr.w	r3, [r1], #4
    127c:	f840 3b04 	str.w	r3, [r0], #4
    1280:	f851 3b04 	ldr.w	r3, [r1], #4
    1284:	f840 3b04 	str.w	r3, [r0], #4
    1288:	f851 3b04 	ldr.w	r3, [r1], #4
    128c:	f840 3b04 	str.w	r3, [r0], #4
    1290:	f851 3b04 	ldr.w	r3, [r1], #4
    1294:	f840 3b04 	str.w	r3, [r0], #4
    1298:	f851 3b04 	ldr.w	r3, [r1], #4
    129c:	f840 3b04 	str.w	r3, [r0], #4
    12a0:	f851 3b04 	ldr.w	r3, [r1], #4
    12a4:	f840 3b04 	str.w	r3, [r0], #4
    12a8:	f851 3b04 	ldr.w	r3, [r1], #4
    12ac:	f840 3b04 	str.w	r3, [r0], #4
    12b0:	f851 3b04 	ldr.w	r3, [r1], #4
    12b4:	f840 3b04 	str.w	r3, [r0], #4
    12b8:	f851 3b04 	ldr.w	r3, [r1], #4
    12bc:	f840 3b04 	str.w	r3, [r0], #4
    12c0:	f851 3b04 	ldr.w	r3, [r1], #4
    12c4:	f840 3b04 	str.w	r3, [r0], #4
    12c8:	f851 3b04 	ldr.w	r3, [r1], #4
    12cc:	f840 3b04 	str.w	r3, [r0], #4
    12d0:	f851 3b04 	ldr.w	r3, [r1], #4
    12d4:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    12d8:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    12da:	d2bd      	bcs.n	1258 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    12dc:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    12de:	d311      	bcc.n	1304 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    12e0:	f851 3b04 	ldr.w	r3, [r1], #4
    12e4:	f840 3b04 	str.w	r3, [r0], #4
    12e8:	f851 3b04 	ldr.w	r3, [r1], #4
    12ec:	f840 3b04 	str.w	r3, [r0], #4
    12f0:	f851 3b04 	ldr.w	r3, [r1], #4
    12f4:	f840 3b04 	str.w	r3, [r0], #4
    12f8:	f851 3b04 	ldr.w	r3, [r1], #4
    12fc:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    1300:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    1302:	d2ed      	bcs.n	12e0 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    1304:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    1306:	d305      	bcc.n	1314 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    1308:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    130c:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    1310:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    1312:	d2f9      	bcs.n	1308 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    1314:	3204      	adds	r2, #4
	beq	.Ldone
    1316:	d00a      	beq.n	132e <memcpy+0xe6>

	lsls	r2, r2, #31
    1318:	07d2      	lsls	r2, r2, #31
	itt ne
    131a:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    131c:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    1320:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    1324:	d303      	bcc.n	132e <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    1326:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    1328:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    132a:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    132c:	7043      	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    132e:	bc01      	pop	{r0}
#endif
	bx	lr
    1330:	4770      	bx	lr
    1332:	bf00      	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    1334:	2a0c      	cmp	r2, #12
	blo	.Lbyte_copy
    1336:	d34a      	bcc.n	13ce <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    1338:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    133c:	d011      	beq.n	1362 <memcpy+0x11a>

	rsb	r3, #4
    133e:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    1342:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    1344:	07db      	lsls	r3, r3, #31
	itt ne
    1346:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    1348:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    134c:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    1350:	d307      	bcc.n	1362 <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    1352:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    1356:	f800 3b01 	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    135a:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    135e:	f800 3b01 	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    1362:	f011 0303 	ands.w	r3, r1, #3
	beq	.Lbig_block
    1366:	f43f af75 	beq.w	1254 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    136a:	b430      	push	{r4, r5}
	subs	r2, #4
    136c:	3a04      	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    136e:	1ac9      	subs	r1, r1, r3
	rsb	ip, r3, #4
    1370:	f1c3 0c04 	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    1374:	f851 4b04 	ldr.w	r4, [r1], #4

	cmp	r3, #2
    1378:	2b02      	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    137a:	d019      	beq.n	13b0 <memcpy+0x168>
	cmp	r3, #3
    137c:	2b03      	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    137e:	d00b      	beq.n	1398 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    1380:	0a24      	lsrs	r4, r4, #8
    1382:	f851 3b04 	ldr.w	r3, [r1], #4
    1386:	061d      	lsls	r5, r3, #24
    1388:	ea44 0405 	orr.w	r4, r4, r5
    138c:	f840 4b04 	str.w	r4, [r0], #4
    1390:	461c      	mov	r4, r3
    1392:	3a04      	subs	r2, #4
    1394:	d2f4      	bcs.n	1380 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    1396:	e016      	b.n	13c6 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    1398:	0e24      	lsrs	r4, r4, #24
    139a:	f851 3b04 	ldr.w	r3, [r1], #4
    139e:	021d      	lsls	r5, r3, #8
    13a0:	ea44 0405 	orr.w	r4, r4, r5
    13a4:	f840 4b04 	str.w	r4, [r0], #4
    13a8:	461c      	mov	r4, r3
    13aa:	3a04      	subs	r2, #4
    13ac:	d2f4      	bcs.n	1398 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    13ae:	e00a      	b.n	13c6 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    13b0:	0c24      	lsrs	r4, r4, #16
    13b2:	f851 3b04 	ldr.w	r3, [r1], #4
    13b6:	041d      	lsls	r5, r3, #16
    13b8:	ea44 0405 	orr.w	r4, r4, r5
    13bc:	f840 4b04 	str.w	r4, [r0], #4
    13c0:	461c      	mov	r4, r3
    13c2:	3a04      	subs	r2, #4
    13c4:	d2f4      	bcs.n	13b0 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    13c6:	3204      	adds	r2, #4
	subs	r1, ip
    13c8:	ebb1 010c 	subs.w	r1, r1, ip
	pop	{r4, r5}
    13cc:	bc30      	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    13ce:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    13d0:	d3a0      	bcc.n	1314 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    13d2:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    13d4:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    13d8:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    13dc:	d2f9      	bcs.n	13d2 <memcpy+0x18a>

	ldrb	r3, [r1]
    13de:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    13e0:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    13e2:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    13e4:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    13e6:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    13e8:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    13ea:	bc01      	pop	{r0}
#endif
	bx	lr
    13ec:	4770      	bx	lr
    13ee:	bf00      	nop

000013f0 <fault_isr>:
{
    13f0:	b508      	push	{r3, lr}
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    13f2:	4c0e      	ldr	r4, [pc, #56]	; (142c <fault_isr+0x3c>)
    13f4:	6b63      	ldr	r3, [r4, #52]	; 0x34
    13f6:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    13fa:	d10e      	bne.n	141a <fault_isr+0x2a>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    13fc:	6b63      	ldr	r3, [r4, #52]	; 0x34
    13fe:	f413 6f80 	tst.w	r3, #1024	; 0x400
    1402:	d10d      	bne.n	1420 <fault_isr+0x30>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    1404:	6b63      	ldr	r3, [r4, #52]	; 0x34
    1406:	f413 6f00 	tst.w	r3, #2048	; 0x800
    140a:	d10c      	bne.n	1426 <fault_isr+0x36>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    140c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    140e:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    1412:	d0ef      	beq.n	13f4 <fault_isr+0x4>
    1414:	f000 f80c 	bl	1430 <unused_isr>
    1418:	e7ec      	b.n	13f4 <fault_isr+0x4>
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    141a:	f000 f9e5 	bl	17e8 <usb_isr>
    141e:	e7ed      	b.n	13fc <fault_isr+0xc>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    1420:	f000 f806 	bl	1430 <unused_isr>
    1424:	e7ee      	b.n	1404 <fault_isr+0x14>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    1426:	f000 f803 	bl	1430 <unused_isr>
    142a:	e7ef      	b.n	140c <fault_isr+0x1c>
    142c:	40048000 	.word	0x40048000

00001430 <unused_isr>:
{
    1430:	b508      	push	{r3, lr}
	fault_isr();
    1432:	f7ff ffdd 	bl	13f0 <fault_isr>
    1436:	Address 0x0000000000001436 is out of bounds.


00001438 <startup_early_hook>:
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    1438:	4b01      	ldr	r3, [pc, #4]	; (1440 <startup_early_hook+0x8>)
    143a:	2210      	movs	r2, #16
    143c:	801a      	strh	r2, [r3, #0]
}
    143e:	4770      	bx	lr
    1440:	40052000 	.word	0x40052000

00001444 <startup_late_hook>:
static void startup_default_late_hook(void) {}
    1444:	4770      	bx	lr

00001446 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    1446:	b530      	push	{r4, r5, lr}
    1448:	4684      	mov	ip, r0
    144a:	4608      	mov	r0, r1
	unsigned digit;
	int i=0, j;
    144c:	3901      	subs	r1, #1
{
    144e:	460d      	mov	r5, r1
	int i=0, j;
    1450:	f04f 0e00 	mov.w	lr, #0
    1454:	e002      	b.n	145c <ultoa+0x16>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    1456:	f10e 0e01 	add.w	lr, lr, #1
		val /= radix;
    145a:	469c      	mov	ip, r3
		digit = val % radix;
    145c:	fbbc f3f2 	udiv	r3, ip, r2
    1460:	fb02 c313 	mls	r3, r2, r3, ip
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    1464:	2b09      	cmp	r3, #9
    1466:	bf94      	ite	ls
    1468:	3330      	addls	r3, #48	; 0x30
    146a:	3337      	addhi	r3, #55	; 0x37
    146c:	b2db      	uxtb	r3, r3
    146e:	4674      	mov	r4, lr
    1470:	f805 3f01 	strb.w	r3, [r5, #1]!
		val /= radix;
    1474:	fbbc f3f2 	udiv	r3, ip, r2
		if (val == 0) break;
    1478:	4562      	cmp	r2, ip
    147a:	d9ec      	bls.n	1456 <ultoa+0x10>
	}
	buf[i + 1] = 0;
    147c:	1c63      	adds	r3, r4, #1
    147e:	eb00 0c03 	add.w	ip, r0, r3
    1482:	2200      	movs	r2, #0
    1484:	54c2      	strb	r2, [r0, r3]
	for (j=0; j < i; j++, i--) {
    1486:	4596      	cmp	lr, r2
    1488:	dd0e      	ble.n	14a8 <ultoa+0x62>
		t = buf[j];
    148a:	460a      	mov	r2, r1
    148c:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		buf[j] = buf[i];
    1490:	f81c 5d01 	ldrb.w	r5, [ip, #-1]!
    1494:	700d      	strb	r5, [r1, #0]
		buf[i] = t;
    1496:	f88c 3000 	strb.w	r3, [ip]
	for (j=0; j < i; j++, i--) {
    149a:	3202      	adds	r2, #2
    149c:	1a12      	subs	r2, r2, r0
    149e:	1a43      	subs	r3, r0, r1
    14a0:	3b01      	subs	r3, #1
    14a2:	4423      	add	r3, r4
    14a4:	429a      	cmp	r2, r3
    14a6:	dbf0      	blt.n	148a <ultoa+0x44>
	}
	return buf;
}
    14a8:	bd30      	pop	{r4, r5, pc}
    14aa:	Address 0x00000000000014aa is out of bounds.


000014ac <rtc_set>:
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    14ac:	4b03      	ldr	r3, [pc, #12]	; (14bc <rtc_set+0x10>)
    14ae:	2200      	movs	r2, #0
    14b0:	615a      	str	r2, [r3, #20]
	RTC_TPR = 0;
    14b2:	605a      	str	r2, [r3, #4]
	RTC_TSR = t;
    14b4:	6018      	str	r0, [r3, #0]
	RTC_SR = RTC_SR_TCE;
    14b6:	2210      	movs	r2, #16
    14b8:	615a      	str	r2, [r3, #20]
}
    14ba:	4770      	bx	lr
    14bc:	4003d000 	.word	0x4003d000

000014c0 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    14c0:	4770      	bx	lr
    14c2:	Address 0x00000000000014c2 is out of bounds.


000014c4 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    14c4:	b510      	push	{r4, lr}
    14c6:	b082      	sub	sp, #8
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    14c8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    14cc:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    14d0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    14d4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    14d8:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    14dc:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
    14e0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    14e4:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
    14e8:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    14ec:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    14f0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    14f4:	4a19      	ldr	r2, [pc, #100]	; (155c <_init_Teensyduino_internal_+0x98>)
    14f6:	2400      	movs	r4, #0
    14f8:	6054      	str	r4, [r2, #4]
	FTM0_MOD = DEFAULT_FTM_MOD;
    14fa:	f648 70ff 	movw	r0, #36863	; 0x8fff
    14fe:	6090      	str	r0, [r2, #8]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    1500:	2328      	movs	r3, #40	; 0x28
    1502:	60d3      	str	r3, [r2, #12]
	FTM0_C1SC = 0x28;
    1504:	6153      	str	r3, [r2, #20]
	FTM0_C2SC = 0x28;
    1506:	61d3      	str	r3, [r2, #28]
	FTM0_C3SC = 0x28;
    1508:	6253      	str	r3, [r2, #36]	; 0x24
	FTM0_C4SC = 0x28;
    150a:	62d3      	str	r3, [r2, #44]	; 0x2c
	FTM0_C5SC = 0x28;
    150c:	6353      	str	r3, [r2, #52]	; 0x34
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    150e:	63d3      	str	r3, [r2, #60]	; 0x3c
	FTM0_C7SC = 0x28;
    1510:	6453      	str	r3, [r2, #68]	; 0x44
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    1512:	2109      	movs	r1, #9
    1514:	6011      	str	r1, [r2, #0]
	FTM1_CNT = 0;
    1516:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    151a:	6054      	str	r4, [r2, #4]
	FTM1_MOD = DEFAULT_FTM_MOD;
    151c:	6090      	str	r0, [r2, #8]
	FTM1_C0SC = 0x28;
    151e:	60d3      	str	r3, [r2, #12]
	FTM1_C1SC = 0x28;
    1520:	6153      	str	r3, [r2, #20]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    1522:	6011      	str	r1, [r2, #0]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    1524:	f502 22fe 	add.w	r2, r2, #520192	; 0x7f000
    1528:	6054      	str	r4, [r2, #4]
	FTM2_MOD = DEFAULT_FTM_MOD;
    152a:	6090      	str	r0, [r2, #8]
	FTM2_C0SC = 0x28;
    152c:	60d3      	str	r3, [r2, #12]
	FTM2_C1SC = 0x28;
    152e:	6153      	str	r3, [r2, #20]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    1530:	6011      	str	r1, [r2, #0]
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
#endif
	analog_init();
    1532:	f001 f823 	bl	257c <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    1536:	f7ff ffc3 	bl	14c0 <startup_middle_hook>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    153a:	4a09      	ldr	r2, [pc, #36]	; (1560 <_init_Teensyduino_internal_+0x9c>)
    153c:	6813      	ldr	r3, [r2, #0]
    153e:	9300      	str	r3, [sp, #0]
	return ret;
    1540:	9b00      	ldr	r3, [sp, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
    1542:	2b13      	cmp	r3, #19
    1544:	d9fa      	bls.n	153c <_init_Teensyduino_internal_+0x78>
	usb_init();
    1546:	f000 fce5 	bl	1f14 <usb_init>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    154a:	4a05      	ldr	r2, [pc, #20]	; (1560 <_init_Teensyduino_internal_+0x9c>)
    154c:	6813      	ldr	r3, [r2, #0]
    154e:	9301      	str	r3, [sp, #4]
	return ret;
    1550:	9b01      	ldr	r3, [sp, #4]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
    1552:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    1556:	d3f9      	bcc.n	154c <_init_Teensyduino_internal_+0x88>
}
    1558:	b002      	add	sp, #8
    155a:	bd10      	pop	{r4, pc}
    155c:	40038000 	.word	0x40038000
    1560:	1fff8b6c 	.word	0x1fff8b6c

00001564 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    1564:	2821      	cmp	r0, #33	; 0x21
    1566:	d83a      	bhi.n	15de <pinMode+0x7a>
	config = portConfigRegister(pin);
    1568:	4b1d      	ldr	r3, [pc, #116]	; (15e0 <pinMode+0x7c>)
    156a:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    156e:	685b      	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    1570:	2901      	cmp	r1, #1
    1572:	d019      	beq.n	15a8 <pinMode+0x44>
    1574:	2904      	cmp	r1, #4
    1576:	d025      	beq.n	15c4 <pinMode+0x60>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    1578:	4a19      	ldr	r2, [pc, #100]	; (15e0 <pinMode+0x7c>)
    157a:	f852 2030 	ldr.w	r2, [r2, r0, lsl #3]
    157e:	2000      	movs	r0, #0
    1580:	f882 0280 	strb.w	r0, [r2, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    1584:	b919      	cbnz	r1, 158e <pinMode+0x2a>
			*config = PORT_PCR_MUX(1);
    1586:	f44f 7280 	mov.w	r2, #256	; 0x100
    158a:	601a      	str	r2, [r3, #0]
    158c:	4770      	bx	lr
		} else if (mode == INPUT_PULLUP) {
    158e:	2902      	cmp	r1, #2
    1590:	d006      	beq.n	15a0 <pinMode+0x3c>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    1592:	2903      	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    1594:	bf0c      	ite	eq
    1596:	f44f 7281 	moveq.w	r2, #258	; 0x102
		} else { // INPUT_DISABLE
			*config = 0;
    159a:	2200      	movne	r2, #0
    159c:	601a      	str	r2, [r3, #0]
    159e:	4770      	bx	lr
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    15a0:	f240 1203 	movw	r2, #259	; 0x103
    15a4:	601a      	str	r2, [r3, #0]
    15a6:	4770      	bx	lr
		*portModeRegister(pin) = 1;
    15a8:	4a0d      	ldr	r2, [pc, #52]	; (15e0 <pinMode+0x7c>)
    15aa:	f852 2030 	ldr.w	r2, [r2, r0, lsl #3]
    15ae:	2101      	movs	r1, #1
    15b0:	f882 1280 	strb.w	r1, [r2, #640]	; 0x280
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    15b4:	f44f 72a2 	mov.w	r2, #324	; 0x144
    15b8:	601a      	str	r2, [r3, #0]
		    *config &= ~PORT_PCR_ODE;
    15ba:	681a      	ldr	r2, [r3, #0]
    15bc:	f022 0220 	bic.w	r2, r2, #32
    15c0:	601a      	str	r2, [r3, #0]
    15c2:	4770      	bx	lr
		*portModeRegister(pin) = 1;
    15c4:	4a06      	ldr	r2, [pc, #24]	; (15e0 <pinMode+0x7c>)
    15c6:	f852 2030 	ldr.w	r2, [r2, r0, lsl #3]
    15ca:	2101      	movs	r1, #1
    15cc:	f882 1280 	strb.w	r1, [r2, #640]	; 0x280
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    15d0:	f44f 72a2 	mov.w	r2, #324	; 0x144
    15d4:	601a      	str	r2, [r3, #0]
		    *config |= PORT_PCR_ODE;
    15d6:	681a      	ldr	r2, [r3, #0]
    15d8:	f042 0220 	orr.w	r2, r2, #32
    15dc:	601a      	str	r2, [r3, #0]
		}
	}
}
    15de:	4770      	bx	lr
    15e0:	00002900 	.word	0x00002900

000015e4 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    15e4:	b672      	cpsid	i
	current = SYST_CVR;
    15e6:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    15ea:	6993      	ldr	r3, [r2, #24]
	count = systick_millis_count;
    15ec:	490c      	ldr	r1, [pc, #48]	; (1620 <micros+0x3c>)
    15ee:	6808      	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    15f0:	f8d2 2d04 	ldr.w	r2, [r2, #3332]	; 0xd04
	__enable_irq();
    15f4:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    15f6:	f012 6f80 	tst.w	r2, #67108864	; 0x4000000
    15fa:	d002      	beq.n	1602 <micros+0x1e>
    15fc:	2b32      	cmp	r3, #50	; 0x32
    15fe:	bf88      	it	hi
    1600:	3001      	addhi	r0, #1
	current = ((F_CPU / 1000) - 1) - current;
    1602:	f5c3 338c 	rsb	r3, r3, #71680	; 0x11800
    1606:	f203 133f 	addw	r3, r3, #319	; 0x13f
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    160a:	4a06      	ldr	r2, [pc, #24]	; (1624 <micros+0x40>)
    160c:	fba2 2303 	umull	r2, r3, r2, r3
    1610:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1614:	fb02 f000 	mul.w	r0, r2, r0
}
    1618:	eb00 1013 	add.w	r0, r0, r3, lsr #4
    161c:	4770      	bx	lr
    161e:	bf00      	nop
    1620:	1fff8b6c 	.word	0x1fff8b6c
    1624:	38e38e39 	.word	0x38e38e39

00001628 <endpoint0_transmit>:
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    1628:	4b0d      	ldr	r3, [pc, #52]	; (1660 <endpoint0_transmit+0x38>)
    162a:	781b      	ldrb	r3, [r3, #0]
    162c:	f043 0c02 	orr.w	ip, r3, #2
    1630:	4a0c      	ldr	r2, [pc, #48]	; (1664 <endpoint0_transmit+0x3c>)
    1632:	eb02 02cc 	add.w	r2, r2, ip, lsl #3
    1636:	6050      	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    1638:	4a0b      	ldr	r2, [pc, #44]	; (1668 <endpoint0_transmit+0x40>)
    163a:	7812      	ldrb	r2, [r2, #0]
    163c:	2a00      	cmp	r2, #0
    163e:	bf14      	ite	ne
    1640:	20c8      	movne	r0, #200	; 0xc8
    1642:	2088      	moveq	r0, #136	; 0x88
    1644:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
    1648:	4906      	ldr	r1, [pc, #24]	; (1664 <endpoint0_transmit+0x3c>)
    164a:	f841 003c 	str.w	r0, [r1, ip, lsl #3]
	ep0_tx_data_toggle ^= 1;
    164e:	f082 0201 	eor.w	r2, r2, #1
    1652:	4905      	ldr	r1, [pc, #20]	; (1668 <endpoint0_transmit+0x40>)
    1654:	700a      	strb	r2, [r1, #0]
	ep0_tx_bdt_bank ^= 1;
    1656:	f083 0301 	eor.w	r3, r3, #1
    165a:	4a01      	ldr	r2, [pc, #4]	; (1660 <endpoint0_transmit+0x38>)
    165c:	7013      	strb	r3, [r2, #0]
}
    165e:	4770      	bx	lr
    1660:	1fff8bf0 	.word	0x1fff8bf0
    1664:	1fff8000 	.word	0x1fff8000
    1668:	1fff8bf1 	.word	0x1fff8bf1

0000166c <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    166c:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    166e:	2b03      	cmp	r3, #3
    1670:	d812      	bhi.n	1698 <usb_rx+0x2c>
	__disable_irq();
    1672:	b672      	cpsid	i
	ret = rx_first[endpoint];
    1674:	4a09      	ldr	r2, [pc, #36]	; (169c <usb_rx+0x30>)
    1676:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
    167a:	b158      	cbz	r0, 1694 <usb_rx+0x28>
		rx_first[endpoint] = ret->next;
    167c:	6841      	ldr	r1, [r0, #4]
    167e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    1682:	4907      	ldr	r1, [pc, #28]	; (16a0 <usb_rx+0x34>)
    1684:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    1688:	f8b0 c000 	ldrh.w	ip, [r0]
    168c:	eba2 020c 	sub.w	r2, r2, ip
    1690:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
    1694:	b662      	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    1696:	4770      	bx	lr
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    1698:	2000      	movs	r0, #0
}
    169a:	4770      	bx	lr
    169c:	1fff8c00 	.word	0x1fff8c00
    16a0:	1fff8c50 	.word	0x1fff8c50

000016a4 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    16a4:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    16a6:	2803      	cmp	r0, #3
    16a8:	d80d      	bhi.n	16c6 <usb_tx_packet_count+0x22>
	__disable_irq();
    16aa:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    16ac:	4b07      	ldr	r3, [pc, #28]	; (16cc <usb_tx_packet_count+0x28>)
    16ae:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    16b2:	b133      	cbz	r3, 16c2 <usb_tx_packet_count+0x1e>
	uint32_t count=0;
    16b4:	2000      	movs	r0, #0
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    16b6:	3001      	adds	r0, #1
    16b8:	685b      	ldr	r3, [r3, #4]
    16ba:	2b00      	cmp	r3, #0
    16bc:	d1fb      	bne.n	16b6 <usb_tx_packet_count+0x12>
	__enable_irq();
    16be:	b662      	cpsie	i
	return count;
    16c0:	4770      	bx	lr
	uint32_t count=0;
    16c2:	2000      	movs	r0, #0
    16c4:	e7fb      	b.n	16be <usb_tx_packet_count+0x1a>
	if (endpoint >= NUM_ENDPOINTS) return 0;
    16c6:	2000      	movs	r0, #0
}
    16c8:	4770      	bx	lr
    16ca:	bf00      	nop
    16cc:	1fff8c28 	.word	0x1fff8c28

000016d0 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    16d0:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    16d2:	b672      	cpsid	i
    16d4:	2304      	movs	r3, #4
	cfg = usb_endpoint_config_table;
    16d6:	4a1c      	ldr	r2, [pc, #112]	; (1748 <usb_rx_memory+0x78>)
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    16d8:	4c1c      	ldr	r4, [pc, #112]	; (174c <usb_rx_memory+0x7c>)
    16da:	e010      	b.n	16fe <usb_rx_memory+0x2e>
				table[index(i, RX, EVEN)].addr = packet->buf;
    16dc:	3008      	adds	r0, #8
    16de:	4a1b      	ldr	r2, [pc, #108]	; (174c <usb_rx_memory+0x7c>)
    16e0:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    16e4:	6048      	str	r0, [r1, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    16e6:	491a      	ldr	r1, [pc, #104]	; (1750 <usb_rx_memory+0x80>)
    16e8:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				usb_rx_memory_needed--;
    16ec:	4a19      	ldr	r2, [pc, #100]	; (1754 <usb_rx_memory+0x84>)
    16ee:	7813      	ldrb	r3, [r2, #0]
    16f0:	3b01      	subs	r3, #1
    16f2:	7013      	strb	r3, [r2, #0]
				__enable_irq();
    16f4:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",even\n");
				return;
    16f6:	e025      	b.n	1744 <usb_rx_memory+0x74>
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    16f8:	3304      	adds	r3, #4
    16fa:	2b14      	cmp	r3, #20
    16fc:	d01c      	beq.n	1738 <usb_rx_memory+0x68>
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    16fe:	f812 1b01 	ldrb.w	r1, [r2], #1
    1702:	f011 0f08 	tst.w	r1, #8
    1706:	d0f7      	beq.n	16f8 <usb_rx_memory+0x28>
			if (table[index(i, RX, EVEN)].desc == 0) {
    1708:	f854 1033 	ldr.w	r1, [r4, r3, lsl #3]
    170c:	2900      	cmp	r1, #0
    170e:	d0e5      	beq.n	16dc <usb_rx_memory+0xc>
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    1710:	f043 0101 	orr.w	r1, r3, #1
    1714:	f854 5031 	ldr.w	r5, [r4, r1, lsl #3]
    1718:	2d00      	cmp	r5, #0
    171a:	d1ed      	bne.n	16f8 <usb_rx_memory+0x28>
				table[index(i, RX, ODD)].addr = packet->buf;
    171c:	3008      	adds	r0, #8
    171e:	4b0b      	ldr	r3, [pc, #44]	; (174c <usb_rx_memory+0x7c>)
    1720:	eb03 02c1 	add.w	r2, r3, r1, lsl #3
    1724:	6050      	str	r0, [r2, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    1726:	4a0c      	ldr	r2, [pc, #48]	; (1758 <usb_rx_memory+0x88>)
    1728:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
				usb_rx_memory_needed--;
    172c:	4a09      	ldr	r2, [pc, #36]	; (1754 <usb_rx_memory+0x84>)
    172e:	7813      	ldrb	r3, [r2, #0]
    1730:	3b01      	subs	r3, #1
    1732:	7013      	strb	r3, [r2, #0]
				__enable_irq();
    1734:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    1736:	e005      	b.n	1744 <usb_rx_memory+0x74>
			}
		}
	}
	__enable_irq();
    1738:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    173a:	4b06      	ldr	r3, [pc, #24]	; (1754 <usb_rx_memory+0x84>)
    173c:	2200      	movs	r2, #0
    173e:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
    1740:	f000 fc72 	bl	2028 <usb_free>
	return;
}
    1744:	bd38      	pop	{r3, r4, r5, pc}
    1746:	bf00      	nop
    1748:	00002a90 	.word	0x00002a90
    174c:	1fff8000 	.word	0x1fff8000
    1750:	00400088 	.word	0x00400088
    1754:	1fff8c58 	.word	0x1fff8c58
    1758:	004000c8 	.word	0x004000c8

0000175c <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    175c:	1e42      	subs	r2, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    175e:	2a03      	cmp	r2, #3
    1760:	d839      	bhi.n	17d6 <usb_tx+0x7a>
{
    1762:	b410      	push	{r4}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    1764:	0140      	lsls	r0, r0, #5
    1766:	f040 0010 	orr.w	r0, r0, #16
    176a:	4b1b      	ldr	r3, [pc, #108]	; (17d8 <usb_tx+0x7c>)
    176c:	4403      	add	r3, r0
	__disable_irq();
    176e:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    1770:	481a      	ldr	r0, [pc, #104]	; (17dc <usb_tx+0x80>)
    1772:	5c80      	ldrb	r0, [r0, r2]
    1774:	2803      	cmp	r0, #3
    1776:	d81b      	bhi.n	17b0 <usb_tx+0x54>
    1778:	e8df f000 	tbb	[pc, r0]
    177c:	1702142b 	.word	0x1702142b
    1780:	2005      	movs	r0, #5
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    1782:	4c16      	ldr	r4, [pc, #88]	; (17dc <usb_tx+0x80>)
    1784:	54a0      	strb	r0, [r4, r2]
	b->addr = packet->buf;
    1786:	f101 0208 	add.w	r2, r1, #8
    178a:	605a      	str	r2, [r3, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    178c:	f013 0f08 	tst.w	r3, #8
    1790:	bf14      	ite	ne
    1792:	22c8      	movne	r2, #200	; 0xc8
    1794:	2288      	moveq	r2, #136	; 0x88
    1796:	8809      	ldrh	r1, [r1, #0]
    1798:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    179c:	601a      	str	r2, [r3, #0]
	__enable_irq();
    179e:	b662      	cpsie	i
}
    17a0:	bc10      	pop	{r4}
    17a2:	4770      	bx	lr
		b++;
    17a4:	3308      	adds	r3, #8
		next = TX_STATE_EVEN_FREE;
    17a6:	2002      	movs	r0, #2
		break;
    17a8:	e7eb      	b.n	1782 <usb_tx+0x26>
		b++;
    17aa:	3308      	adds	r3, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    17ac:	2004      	movs	r0, #4
		break;
    17ae:	e7e8      	b.n	1782 <usb_tx+0x26>
		if (tx_first[endpoint] == NULL) {
    17b0:	4b0b      	ldr	r3, [pc, #44]	; (17e0 <usb_tx+0x84>)
    17b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    17b6:	b93b      	cbnz	r3, 17c8 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
    17b8:	4b09      	ldr	r3, [pc, #36]	; (17e0 <usb_tx+0x84>)
    17ba:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		tx_last[endpoint] = packet;
    17be:	4b09      	ldr	r3, [pc, #36]	; (17e4 <usb_tx+0x88>)
    17c0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		__enable_irq();
    17c4:	b662      	cpsie	i
		return;
    17c6:	e7eb      	b.n	17a0 <usb_tx+0x44>
			tx_last[endpoint]->next = packet;
    17c8:	4b06      	ldr	r3, [pc, #24]	; (17e4 <usb_tx+0x88>)
    17ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    17ce:	6059      	str	r1, [r3, #4]
    17d0:	e7f5      	b.n	17be <usb_tx+0x62>
		next = TX_STATE_ODD_FREE;
    17d2:	2003      	movs	r0, #3
    17d4:	e7d5      	b.n	1782 <usb_tx+0x26>
    17d6:	4770      	bx	lr
    17d8:	1fff8000 	.word	0x1fff8000
    17dc:	1fff8c48 	.word	0x1fff8c48
    17e0:	1fff8c28 	.word	0x1fff8c28
    17e4:	1fff8c38 	.word	0x1fff8c38

000017e8 <usb_isr>:
}



void usb_isr(void)
{
    17e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    17ec:	b085      	sub	sp, #20
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    17ee:	4ca3      	ldr	r4, [pc, #652]	; (1a7c <usb_isr+0x294>)
    17f0:	f8df a28c 	ldr.w	sl, [pc, #652]	; 1a80 <usb_isr+0x298>
    17f4:	e1a0      	b.n	1b38 <usb_isr+0x350>
	__asm__ volatile("bkpt");
    17f6:	be00      	bkpt	0x0000
				if (t == 0) usb_serial_flush_callback();
    17f8:	f000 fde4 	bl	23c4 <usb_serial_flush_callback>
    17fc:	e1be      	b.n	1b7c <usb_isr+0x394>
	b = stat2bufferdescriptor(stat);
    17fe:	0895      	lsrs	r5, r2, #2
    1800:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
	pid = BDT_PID(b->desc);
    1804:	f854 3035 	ldr.w	r3, [r4, r5, lsl #3]
    1808:	f3c3 0383 	ubfx	r3, r3, #2, #4
	buf = b->addr;
    180c:	6852      	ldr	r2, [r2, #4]
	switch (pid) {
    180e:	2b09      	cmp	r3, #9
    1810:	f000 8277 	beq.w	1d02 <usb_isr+0x51a>
    1814:	d80e      	bhi.n	1834 <usb_isr+0x4c>
    1816:	3b01      	subs	r3, #1
    1818:	2b01      	cmp	r3, #1
    181a:	f200 8185 	bhi.w	1b28 <usb_isr+0x340>
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    181e:	4b99      	ldr	r3, [pc, #612]	; (1a84 <usb_isr+0x29c>)
    1820:	8819      	ldrh	r1, [r3, #0]
    1822:	f242 0321 	movw	r3, #8225	; 0x2021
    1826:	4299      	cmp	r1, r3
    1828:	f000 8253 	beq.w	1cd2 <usb_isr+0x4ea>
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    182c:	4b96      	ldr	r3, [pc, #600]	; (1a88 <usb_isr+0x2a0>)
    182e:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
		break;
    1832:	e179      	b.n	1b28 <usb_isr+0x340>
	switch (pid) {
    1834:	2b0d      	cmp	r3, #13
    1836:	f040 8177 	bne.w	1b28 <usb_isr+0x340>
		setup.word1 = *(uint32_t *)(buf);
    183a:	6811      	ldr	r1, [r2, #0]
    183c:	4b91      	ldr	r3, [pc, #580]	; (1a84 <usb_isr+0x29c>)
    183e:	6019      	str	r1, [r3, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    1840:	6852      	ldr	r2, [r2, #4]
    1842:	605a      	str	r2, [r3, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    1844:	4b90      	ldr	r3, [pc, #576]	; (1a88 <usb_isr+0x2a0>)
    1846:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
		ep0_tx_ptr = NULL;
    184a:	2300      	movs	r3, #0
    184c:	488f      	ldr	r0, [pc, #572]	; (1a8c <usb_isr+0x2a4>)
    184e:	6003      	str	r3, [r0, #0]
		table[index(0, TX, EVEN)].desc = 0;
    1850:	6123      	str	r3, [r4, #16]
		table[index(0, TX, ODD)].desc = 0;
    1852:	61a3      	str	r3, [r4, #24]
		ep0_tx_data_toggle = 1;
    1854:	4b8e      	ldr	r3, [pc, #568]	; (1a90 <usb_isr+0x2a8>)
    1856:	2001      	movs	r0, #1
    1858:	7018      	strb	r0, [r3, #0]
	switch (setup.wRequestAndType) {
    185a:	b28b      	uxth	r3, r1
    185c:	f240 6081 	movw	r0, #1665	; 0x681
    1860:	4283      	cmp	r3, r0
    1862:	d83c      	bhi.n	18de <usb_isr+0xf6>
    1864:	f5b3 6fd0 	cmp.w	r3, #1664	; 0x680
    1868:	f080 81fc 	bcs.w	1c64 <usb_isr+0x47c>
    186c:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    1870:	f000 81dd 	beq.w	1c2e <usb_isr+0x446>
    1874:	d912      	bls.n	189c <usb_isr+0xb4>
    1876:	f240 3002 	movw	r0, #770	; 0x302
    187a:	4283      	cmp	r3, r0
    187c:	d127      	bne.n	18ce <usb_isr+0xe6>
		i = setup.wIndex & 0x7F;
    187e:	f002 027f 	and.w	r2, r2, #127	; 0x7f
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    1882:	2a04      	cmp	r2, #4
    1884:	f300 81e9 	bgt.w	1c5a <usb_isr+0x472>
    1888:	0c09      	lsrs	r1, r1, #16
    188a:	f040 81e6 	bne.w	1c5a <usb_isr+0x472>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    188e:	f81a 3022 	ldrb.w	r3, [sl, r2, lsl #2]
    1892:	f043 0302 	orr.w	r3, r3, #2
    1896:	f80a 3022 	strb.w	r3, [sl, r2, lsl #2]
		break;
    189a:	e1d4      	b.n	1c46 <usb_isr+0x45e>
	switch (setup.wRequestAndType) {
    189c:	2b80      	cmp	r3, #128	; 0x80
    189e:	f000 81bb 	beq.w	1c18 <usb_isr+0x430>
    18a2:	2b82      	cmp	r3, #130	; 0x82
    18a4:	d143      	bne.n	192e <usb_isr+0x146>
		i = setup.wIndex & 0x7F;
    18a6:	f002 027f 	and.w	r2, r2, #127	; 0x7f
		if (i > NUM_ENDPOINTS) {
    18aa:	2a04      	cmp	r2, #4
    18ac:	f300 81ba 	bgt.w	1c24 <usb_isr+0x43c>
		reply_buffer[0] = 0;
    18b0:	4b78      	ldr	r3, [pc, #480]	; (1a94 <usb_isr+0x2ac>)
    18b2:	2100      	movs	r1, #0
    18b4:	7019      	strb	r1, [r3, #0]
		reply_buffer[1] = 0;
    18b6:	7059      	strb	r1, [r3, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    18b8:	f81a 3022 	ldrb.w	r3, [sl, r2, lsl #2]
    18bc:	f013 0f02 	tst.w	r3, #2
    18c0:	f000 8311 	beq.w	1ee6 <usb_isr+0x6fe>
    18c4:	4b73      	ldr	r3, [pc, #460]	; (1a94 <usb_isr+0x2ac>)
    18c6:	2201      	movs	r2, #1
    18c8:	701a      	strb	r2, [r3, #0]
		datalen = 2;
    18ca:	2202      	movs	r2, #2
    18cc:	e107      	b.n	1ade <usb_isr+0x2f6>
	switch (setup.wRequestAndType) {
    18ce:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    18d2:	d12c      	bne.n	192e <usb_isr+0x146>
	endpoint0_transmit(data, size);
    18d4:	2100      	movs	r1, #0
    18d6:	4608      	mov	r0, r1
    18d8:	f7ff fea6 	bl	1628 <endpoint0_transmit>
	if (datalen == 0 && size < EP0_SIZE) return;
    18dc:	e120      	b.n	1b20 <usb_isr+0x338>
	switch (setup.wRequestAndType) {
    18de:	f242 0021 	movw	r0, #8225	; 0x2021
    18e2:	4283      	cmp	r3, r0
    18e4:	f000 811c 	beq.w	1b20 <usb_isr+0x338>
    18e8:	d910      	bls.n	190c <usb_isr+0x124>
    18ea:	f242 2021 	movw	r0, #8737	; 0x2221
    18ee:	4283      	cmp	r3, r0
    18f0:	d119      	bne.n	1926 <usb_isr+0x13e>
		switch (setup.wIndex) {
    18f2:	b292      	uxth	r2, r2
    18f4:	2a00      	cmp	r2, #0
    18f6:	f040 81a6 	bne.w	1c46 <usb_isr+0x45e>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    18fa:	4b67      	ldr	r3, [pc, #412]	; (1a98 <usb_isr+0x2b0>)
    18fc:	681a      	ldr	r2, [r3, #0]
    18fe:	4b67      	ldr	r3, [pc, #412]	; (1a9c <usb_isr+0x2b4>)
    1900:	601a      	str	r2, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    1902:	f3c1 4107 	ubfx	r1, r1, #16, #8
    1906:	4b66      	ldr	r3, [pc, #408]	; (1aa0 <usb_isr+0x2b8>)
    1908:	7019      	strb	r1, [r3, #0]
			break;
    190a:	e19c      	b.n	1c46 <usb_isr+0x45e>
	switch (setup.wRequestAndType) {
    190c:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    1910:	f000 80e0 	beq.w	1ad4 <usb_isr+0x2ec>
    1914:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    1918:	d109      	bne.n	192e <usb_isr+0x146>
		usb_configuration = setup.wValue;
    191a:	f3c1 4107 	ubfx	r1, r1, #16, #8
    191e:	4b61      	ldr	r3, [pc, #388]	; (1aa4 <usb_isr+0x2bc>)
    1920:	7019      	strb	r1, [r3, #0]
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    1922:	2504      	movs	r5, #4
    1924:	e011      	b.n	194a <usb_isr+0x162>
	switch (setup.wRequestAndType) {
    1926:	f242 3221 	movw	r2, #8993	; 0x2321
    192a:	4293      	cmp	r3, r2
    192c:	d0d2      	beq.n	18d4 <usb_isr+0xec>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    192e:	4b5e      	ldr	r3, [pc, #376]	; (1aa8 <usb_isr+0x2c0>)
    1930:	220f      	movs	r2, #15
    1932:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
}
    1936:	e0f3      	b.n	1b20 <usb_isr+0x338>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    1938:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
    193c:	6858      	ldr	r0, [r3, #4]
    193e:	3808      	subs	r0, #8
    1940:	f000 fb72 	bl	2028 <usb_free>
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    1944:	3501      	adds	r5, #1
    1946:	2d14      	cmp	r5, #20
    1948:	d005      	beq.n	1956 <usb_isr+0x16e>
			if (table[i].desc & BDT_OWN) {
    194a:	f854 3035 	ldr.w	r3, [r4, r5, lsl #3]
    194e:	f013 0f80 	tst.w	r3, #128	; 0x80
    1952:	d0f7      	beq.n	1944 <usb_isr+0x15c>
    1954:	e7f0      	b.n	1938 <usb_isr+0x150>
    1956:	4f55      	ldr	r7, [pc, #340]	; (1aac <usb_isr+0x2c4>)
    1958:	f8df 9154 	ldr.w	r9, [pc, #340]	; 1ab0 <usb_isr+0x2c8>
    195c:	f8df 8154 	ldr.w	r8, [pc, #340]	; 1ab4 <usb_isr+0x2cc>
    1960:	4b55      	ldr	r3, [pc, #340]	; (1ab8 <usb_isr+0x2d0>)
    1962:	9301      	str	r3, [sp, #4]
    1964:	4b55      	ldr	r3, [pc, #340]	; (1abc <usb_isr+0x2d4>)
    1966:	9302      	str	r3, [sp, #8]
    1968:	f8df b154 	ldr.w	fp, [pc, #340]	; 1ac0 <usb_isr+0x2d8>
			rx_first[i] = NULL;
    196c:	2600      	movs	r6, #0
    196e:	e006      	b.n	197e <usb_isr+0x196>
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    1970:	f889 6000 	strb.w	r6, [r9]
		for (i=0; i < NUM_ENDPOINTS; i++) {
    1974:	f109 0901 	add.w	r9, r9, #1
    1978:	4b52      	ldr	r3, [pc, #328]	; (1ac4 <usb_isr+0x2dc>)
    197a:	429f      	cmp	r7, r3
    197c:	d039      	beq.n	19f2 <usb_isr+0x20a>
			p = rx_first[i];
    197e:	f857 5b04 	ldr.w	r5, [r7], #4
			while (p) {
    1982:	b12d      	cbz	r5, 1990 <usb_isr+0x1a8>
				n = p->next;
    1984:	4628      	mov	r0, r5
    1986:	686d      	ldr	r5, [r5, #4]
				usb_free(p);
    1988:	f000 fb4e 	bl	2028 <usb_free>
			while (p) {
    198c:	2d00      	cmp	r5, #0
    198e:	d1f9      	bne.n	1984 <usb_isr+0x19c>
			rx_first[i] = NULL;
    1990:	f847 6c04 	str.w	r6, [r7, #-4]
			rx_last[i] = NULL;
    1994:	f84b 6b04 	str.w	r6, [fp], #4
			p = tx_first[i];
    1998:	f8cd 800c 	str.w	r8, [sp, #12]
    199c:	f8d8 5000 	ldr.w	r5, [r8]
			while (p) {
    19a0:	b12d      	cbz	r5, 19ae <usb_isr+0x1c6>
				n = p->next;
    19a2:	4628      	mov	r0, r5
    19a4:	686d      	ldr	r5, [r5, #4]
				usb_free(p);
    19a6:	f000 fb3f 	bl	2028 <usb_free>
			while (p) {
    19aa:	2d00      	cmp	r5, #0
    19ac:	d1f9      	bne.n	19a2 <usb_isr+0x1ba>
			tx_first[i] = NULL;
    19ae:	9b03      	ldr	r3, [sp, #12]
    19b0:	601e      	str	r6, [r3, #0]
    19b2:	f108 0804 	add.w	r8, r8, #4
			tx_last[i] = NULL;
    19b6:	9b01      	ldr	r3, [sp, #4]
    19b8:	f843 6b04 	str.w	r6, [r3], #4
    19bc:	9301      	str	r3, [sp, #4]
			usb_rx_byte_count_data[i] = 0;
    19be:	9b02      	ldr	r3, [sp, #8]
    19c0:	f823 6b02 	strh.w	r6, [r3], #2
    19c4:	9302      	str	r3, [sp, #8]
			switch (tx_state[i]) {
    19c6:	f899 3000 	ldrb.w	r3, [r9]
    19ca:	3b02      	subs	r3, #2
    19cc:	2b03      	cmp	r3, #3
    19ce:	d8d1      	bhi.n	1974 <usb_isr+0x18c>
    19d0:	a201      	add	r2, pc, #4	; (adr r2, 19d8 <usb_isr+0x1f0>)
    19d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    19d6:	bf00      	nop
    19d8:	00001971 	.word	0x00001971
    19dc:	000019e9 	.word	0x000019e9
    19e0:	00001971 	.word	0x00001971
    19e4:	000019e9 	.word	0x000019e9
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    19e8:	f04f 0301 	mov.w	r3, #1
    19ec:	f889 3000 	strb.w	r3, [r9]
				break;
    19f0:	e7c0      	b.n	1974 <usb_isr+0x18c>
		usb_rx_memory_needed = 0;
    19f2:	4b35      	ldr	r3, [pc, #212]	; (1ac8 <usb_isr+0x2e0>)
    19f4:	2200      	movs	r2, #0
    19f6:	701a      	strb	r2, [r3, #0]
    19f8:	2504      	movs	r5, #4
		cfg = usb_endpoint_config_table;
    19fa:	4f34      	ldr	r7, [pc, #208]	; (1acc <usb_isr+0x2e4>)
					table[index(i, RX, ODD)].desc = 0;
    19fc:	4616      	mov	r6, r2
    19fe:	e01a      	b.n	1a36 <usb_isr+0x24e>
					table[index(i, RX, EVEN)].desc = 0;
    1a00:	f844 6035 	str.w	r6, [r4, r5, lsl #3]
					usb_rx_memory_needed++;
    1a04:	4a30      	ldr	r2, [pc, #192]	; (1ac8 <usb_isr+0x2e0>)
    1a06:	7813      	ldrb	r3, [r2, #0]
    1a08:	3301      	adds	r3, #1
    1a0a:	7013      	strb	r3, [r2, #0]
    1a0c:	e026      	b.n	1a5c <usb_isr+0x274>
					table[index(i, RX, ODD)].desc = 0;
    1a0e:	f045 0301 	orr.w	r3, r5, #1
    1a12:	f844 6033 	str.w	r6, [r4, r3, lsl #3]
					usb_rx_memory_needed++;
    1a16:	4a2c      	ldr	r2, [pc, #176]	; (1ac8 <usb_isr+0x2e0>)
    1a18:	7813      	ldrb	r3, [r2, #0]
    1a1a:	3301      	adds	r3, #1
    1a1c:	7013      	strb	r3, [r2, #0]
			table[index(i, TX, EVEN)].desc = 0;
    1a1e:	f045 0302 	orr.w	r3, r5, #2
    1a22:	f844 6033 	str.w	r6, [r4, r3, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    1a26:	f045 0303 	orr.w	r3, r5, #3
    1a2a:	f844 6033 	str.w	r6, [r4, r3, lsl #3]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    1a2e:	3504      	adds	r5, #4
    1a30:	2d14      	cmp	r5, #20
    1a32:	f000 8108 	beq.w	1c46 <usb_isr+0x45e>
			epconf = *cfg++;
    1a36:	f817 3b01 	ldrb.w	r3, [r7], #1
			*reg = epconf;
    1a3a:	f805 300a 	strb.w	r3, [r5, sl]
			if (epconf & USB_ENDPT_EPRXEN) {
    1a3e:	f013 0f08 	tst.w	r3, #8
    1a42:	d0ec      	beq.n	1a1e <usb_isr+0x236>
				p = usb_malloc();
    1a44:	f000 fad0 	bl	1fe8 <usb_malloc>
				if (p) {
    1a48:	4603      	mov	r3, r0
    1a4a:	2800      	cmp	r0, #0
    1a4c:	d0d8      	beq.n	1a00 <usb_isr+0x218>
					table[index(i, RX, EVEN)].addr = p->buf;
    1a4e:	3308      	adds	r3, #8
    1a50:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
    1a54:	6053      	str	r3, [r2, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    1a56:	4b1e      	ldr	r3, [pc, #120]	; (1ad0 <usb_isr+0x2e8>)
    1a58:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
				p = usb_malloc();
    1a5c:	f000 fac4 	bl	1fe8 <usb_malloc>
				if (p) {
    1a60:	4602      	mov	r2, r0
    1a62:	2800      	cmp	r0, #0
    1a64:	d0d3      	beq.n	1a0e <usb_isr+0x226>
					table[index(i, RX, ODD)].addr = p->buf;
    1a66:	f045 0301 	orr.w	r3, r5, #1
    1a6a:	3208      	adds	r2, #8
    1a6c:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    1a70:	604a      	str	r2, [r1, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    1a72:	4a05      	ldr	r2, [pc, #20]	; (1a88 <usb_isr+0x2a0>)
    1a74:	f844 2033 	str.w	r2, [r4, r3, lsl #3]
    1a78:	e7d1      	b.n	1a1e <usb_isr+0x236>
    1a7a:	bf00      	nop
    1a7c:	1fff8000 	.word	0x1fff8000
    1a80:	400720c0 	.word	0x400720c0
    1a84:	1fff8c20 	.word	0x1fff8c20
    1a88:	004000c8 	.word	0x004000c8
    1a8c:	1fff8bf4 	.word	0x1fff8bf4
    1a90:	1fff8bf1 	.word	0x1fff8bf1
    1a94:	1fff8bf8 	.word	0x1fff8bf8
    1a98:	1fff8b6c 	.word	0x1fff8b6c
    1a9c:	1fff8c74 	.word	0x1fff8c74
    1aa0:	1fff8c70 	.word	0x1fff8c70
    1aa4:	1fff8c4c 	.word	0x1fff8c4c
    1aa8:	40072000 	.word	0x40072000
    1aac:	1fff8c00 	.word	0x1fff8c00
    1ab0:	1fff8c48 	.word	0x1fff8c48
    1ab4:	1fff8c28 	.word	0x1fff8c28
    1ab8:	1fff8c38 	.word	0x1fff8c38
    1abc:	1fff8c50 	.word	0x1fff8c50
    1ac0:	1fff8c10 	.word	0x1fff8c10
    1ac4:	1fff8c10 	.word	0x1fff8c10
    1ac8:	1fff8c58 	.word	0x1fff8c58
    1acc:	00002a90 	.word	0x00002a90
    1ad0:	00400088 	.word	0x00400088
		reply_buffer[0] = usb_configuration;
    1ad4:	4baa      	ldr	r3, [pc, #680]	; (1d80 <usb_isr+0x598>)
    1ad6:	781a      	ldrb	r2, [r3, #0]
    1ad8:	4baa      	ldr	r3, [pc, #680]	; (1d84 <usb_isr+0x59c>)
    1ada:	701a      	strb	r2, [r3, #0]
		datalen = 1;
    1adc:	2201      	movs	r2, #1
	if (datalen > setup.wLength) datalen = setup.wLength;
    1ade:	4baa      	ldr	r3, [pc, #680]	; (1d88 <usb_isr+0x5a0>)
    1ae0:	88de      	ldrh	r6, [r3, #6]
    1ae2:	4296      	cmp	r6, r2
    1ae4:	bf28      	it	cs
    1ae6:	4616      	movcs	r6, r2
	if (size > EP0_SIZE) size = EP0_SIZE;
    1ae8:	4637      	mov	r7, r6
    1aea:	2e40      	cmp	r6, #64	; 0x40
    1aec:	bf28      	it	cs
    1aee:	2740      	movcs	r7, #64	; 0x40
	endpoint0_transmit(data, size);
    1af0:	4da4      	ldr	r5, [pc, #656]	; (1d84 <usb_isr+0x59c>)
    1af2:	4639      	mov	r1, r7
    1af4:	4628      	mov	r0, r5
    1af6:	f7ff fd97 	bl	1628 <endpoint0_transmit>
	data += size;
    1afa:	443d      	add	r5, r7
	if (datalen == 0 && size < EP0_SIZE) return;
    1afc:	1bf6      	subs	r6, r6, r7
    1afe:	d00f      	beq.n	1b20 <usb_isr+0x338>
	if (size > EP0_SIZE) size = EP0_SIZE;
    1b00:	4637      	mov	r7, r6
    1b02:	2e40      	cmp	r6, #64	; 0x40
    1b04:	bf28      	it	cs
    1b06:	2740      	movcs	r7, #64	; 0x40
	endpoint0_transmit(data, size);
    1b08:	4639      	mov	r1, r7
    1b0a:	4628      	mov	r0, r5
    1b0c:	f7ff fd8c 	bl	1628 <endpoint0_transmit>
	data += size;
    1b10:	443d      	add	r5, r7
	if (datalen == 0 && size < EP0_SIZE) return;
    1b12:	1bf7      	subs	r7, r6, r7
    1b14:	f000 80d9 	beq.w	1cca <usb_isr+0x4e2>
	ep0_tx_ptr = data;
    1b18:	4b9c      	ldr	r3, [pc, #624]	; (1d8c <usb_isr+0x5a4>)
    1b1a:	601d      	str	r5, [r3, #0]
	ep0_tx_len = datalen;
    1b1c:	4b9c      	ldr	r3, [pc, #624]	; (1d90 <usb_isr+0x5a8>)
    1b1e:	801f      	strh	r7, [r3, #0]
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    1b20:	4b9c      	ldr	r3, [pc, #624]	; (1d94 <usb_isr+0x5ac>)
    1b22:	2201      	movs	r2, #1
    1b24:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    1b28:	4b9a      	ldr	r3, [pc, #616]	; (1d94 <usb_isr+0x5ac>)
    1b2a:	2201      	movs	r2, #1
    1b2c:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    1b30:	4b98      	ldr	r3, [pc, #608]	; (1d94 <usb_isr+0x5ac>)
    1b32:	2208      	movs	r2, #8
    1b34:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	status = USB0_ISTAT;
    1b38:	4b96      	ldr	r3, [pc, #600]	; (1d94 <usb_isr+0x5ac>)
    1b3a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
    1b3e:	b2dd      	uxtb	r5, r3
	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    1b40:	f013 0f04 	tst.w	r3, #4
    1b44:	d01e      	beq.n	1b84 <usb_isr+0x39c>
		if (usb_configuration) {
    1b46:	4b8e      	ldr	r3, [pc, #568]	; (1d80 <usb_isr+0x598>)
    1b48:	781b      	ldrb	r3, [r3, #0]
    1b4a:	b1bb      	cbz	r3, 1b7c <usb_isr+0x394>
			t = usb_reboot_timer;
    1b4c:	4b92      	ldr	r3, [pc, #584]	; (1d98 <usb_isr+0x5b0>)
    1b4e:	781a      	ldrb	r2, [r3, #0]
			if (t) {
    1b50:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    1b54:	b132      	cbz	r2, 1b64 <usb_isr+0x37c>
				usb_reboot_timer = --t;
    1b56:	3b01      	subs	r3, #1
    1b58:	b2db      	uxtb	r3, r3
    1b5a:	4a8f      	ldr	r2, [pc, #572]	; (1d98 <usb_isr+0x5b0>)
    1b5c:	7013      	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    1b5e:	2b00      	cmp	r3, #0
    1b60:	f43f ae49 	beq.w	17f6 <usb_isr+0xe>
			t = usb_cdc_transmit_flush_timer;
    1b64:	4b8d      	ldr	r3, [pc, #564]	; (1d9c <usb_isr+0x5b4>)
    1b66:	781a      	ldrb	r2, [r3, #0]
			if (t) {
    1b68:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    1b6c:	b132      	cbz	r2, 1b7c <usb_isr+0x394>
				usb_cdc_transmit_flush_timer = --t;
    1b6e:	3b01      	subs	r3, #1
    1b70:	b2db      	uxtb	r3, r3
    1b72:	4a8a      	ldr	r2, [pc, #552]	; (1d9c <usb_isr+0x5b4>)
    1b74:	7013      	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    1b76:	2b00      	cmp	r3, #0
    1b78:	f43f ae3e 	beq.w	17f8 <usb_isr+0x10>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    1b7c:	4b85      	ldr	r3, [pc, #532]	; (1d94 <usb_isr+0x5ac>)
    1b7e:	2204      	movs	r2, #4
    1b80:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    1b84:	f015 0f08 	tst.w	r5, #8
    1b88:	f000 8165 	beq.w	1e56 <usb_isr+0x66e>
		stat = USB0_STAT;
    1b8c:	4b81      	ldr	r3, [pc, #516]	; (1d94 <usb_isr+0x5ac>)
    1b8e:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
    1b92:	b2da      	uxtb	r2, r3
		if (endpoint == 0) {
    1b94:	091b      	lsrs	r3, r3, #4
    1b96:	f43f ae32 	beq.w	17fe <usb_isr+0x16>
			bdt_t *b = stat2bufferdescriptor(stat);
    1b9a:	0896      	lsrs	r6, r2, #2
    1b9c:	eb04 07c6 	add.w	r7, r4, r6, lsl #3
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    1ba0:	6879      	ldr	r1, [r7, #4]
    1ba2:	f1a1 0008 	sub.w	r0, r1, #8
			endpoint--;	// endpoint is index to zero-based arrays
    1ba6:	3b01      	subs	r3, #1
    1ba8:	b2dd      	uxtb	r5, r3
			if (stat & 0x08) { // transmit
    1baa:	f012 0f08 	tst.w	r2, #8
    1bae:	f040 80d0 	bne.w	1d52 <usb_isr+0x56a>
				packet->len = b->desc >> 16;
    1bb2:	f854 3036 	ldr.w	r3, [r4, r6, lsl #3]
    1bb6:	0c1b      	lsrs	r3, r3, #16
    1bb8:	f821 3c08 	strh.w	r3, [r1, #-8]
				if (packet->len > 0) {
    1bbc:	2b00      	cmp	r3, #0
    1bbe:	f000 8141 	beq.w	1e44 <usb_isr+0x65c>
					packet->index = 0;
    1bc2:	2300      	movs	r3, #0
    1bc4:	f821 3c06 	strh.w	r3, [r1, #-6]
					packet->next = NULL;
    1bc8:	f841 3c04 	str.w	r3, [r1, #-4]
					if (rx_first[endpoint] == NULL) {
    1bcc:	4b74      	ldr	r3, [pc, #464]	; (1da0 <usb_isr+0x5b8>)
    1bce:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
    1bd2:	2b00      	cmp	r3, #0
    1bd4:	f000 812a 	beq.w	1e2c <usb_isr+0x644>
						rx_last[endpoint]->next = packet;
    1bd8:	4b72      	ldr	r3, [pc, #456]	; (1da4 <usb_isr+0x5bc>)
    1bda:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
    1bde:	6058      	str	r0, [r3, #4]
					rx_last[endpoint] = packet;
    1be0:	4b70      	ldr	r3, [pc, #448]	; (1da4 <usb_isr+0x5bc>)
    1be2:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    1be6:	4a70      	ldr	r2, [pc, #448]	; (1da8 <usb_isr+0x5c0>)
    1be8:	f832 3015 	ldrh.w	r3, [r2, r5, lsl #1]
    1bec:	f831 1c08 	ldrh.w	r1, [r1, #-8]
    1bf0:	440b      	add	r3, r1
    1bf2:	f822 3015 	strh.w	r3, [r2, r5, lsl #1]
					packet = usb_malloc();
    1bf6:	f000 f9f7 	bl	1fe8 <usb_malloc>
					if (packet) {
    1bfa:	4603      	mov	r3, r0
    1bfc:	2800      	cmp	r0, #0
    1bfe:	f000 8119 	beq.w	1e34 <usb_isr+0x64c>
						b->addr = packet->buf;
    1c02:	3308      	adds	r3, #8
    1c04:	607b      	str	r3, [r7, #4]
						b->desc = BDT_DESC(64,
    1c06:	f017 0f08 	tst.w	r7, #8
    1c0a:	4b68      	ldr	r3, [pc, #416]	; (1dac <usb_isr+0x5c4>)
    1c0c:	4a68      	ldr	r2, [pc, #416]	; (1db0 <usb_isr+0x5c8>)
    1c0e:	bf08      	it	eq
    1c10:	4613      	moveq	r3, r2
    1c12:	f844 3036 	str.w	r3, [r4, r6, lsl #3]
    1c16:	e78b      	b.n	1b30 <usb_isr+0x348>
		reply_buffer[0] = 0;
    1c18:	4b5a      	ldr	r3, [pc, #360]	; (1d84 <usb_isr+0x59c>)
    1c1a:	2200      	movs	r2, #0
    1c1c:	701a      	strb	r2, [r3, #0]
		reply_buffer[1] = 0;
    1c1e:	705a      	strb	r2, [r3, #1]
		datalen = 2;
    1c20:	2202      	movs	r2, #2
		break;
    1c22:	e75c      	b.n	1ade <usb_isr+0x2f6>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1c24:	4b5b      	ldr	r3, [pc, #364]	; (1d94 <usb_isr+0x5ac>)
    1c26:	220f      	movs	r2, #15
    1c28:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
}
    1c2c:	e778      	b.n	1b20 <usb_isr+0x338>
		i = setup.wIndex & 0x7F;
    1c2e:	f002 027f 	and.w	r2, r2, #127	; 0x7f
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    1c32:	2a04      	cmp	r2, #4
    1c34:	dc0c      	bgt.n	1c50 <usb_isr+0x468>
    1c36:	0c09      	lsrs	r1, r1, #16
    1c38:	d10a      	bne.n	1c50 <usb_isr+0x468>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    1c3a:	f81a 3022 	ldrb.w	r3, [sl, r2, lsl #2]
    1c3e:	f023 0302 	bic.w	r3, r3, #2
    1c42:	f80a 3022 	strb.w	r3, [sl, r2, lsl #2]
	endpoint0_transmit(data, size);
    1c46:	2100      	movs	r1, #0
    1c48:	4608      	mov	r0, r1
    1c4a:	f7ff fced 	bl	1628 <endpoint0_transmit>
	if (datalen == 0 && size < EP0_SIZE) return;
    1c4e:	e767      	b.n	1b20 <usb_isr+0x338>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1c50:	4b50      	ldr	r3, [pc, #320]	; (1d94 <usb_isr+0x5ac>)
    1c52:	220f      	movs	r2, #15
    1c54:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
}
    1c58:	e762      	b.n	1b20 <usb_isr+0x338>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1c5a:	4b4e      	ldr	r3, [pc, #312]	; (1d94 <usb_isr+0x5ac>)
    1c5c:	220f      	movs	r2, #15
    1c5e:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
}
    1c62:	e75d      	b.n	1b20 <usb_isr+0x338>
			if (list->addr == NULL) break;
    1c64:	4b53      	ldr	r3, [pc, #332]	; (1db4 <usb_isr+0x5cc>)
    1c66:	685d      	ldr	r5, [r3, #4]
    1c68:	b355      	cbz	r5, 1cc0 <usb_isr+0x4d8>
    1c6a:	f3c1 410f 	ubfx	r1, r1, #16, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    1c6e:	b292      	uxth	r2, r2
    1c70:	e002      	b.n	1c78 <usb_isr+0x490>
		for (list = usb_descriptor_list; 1; list++) {
    1c72:	330c      	adds	r3, #12
			if (list->addr == NULL) break;
    1c74:	685d      	ldr	r5, [r3, #4]
    1c76:	b31d      	cbz	r5, 1cc0 <usb_isr+0x4d8>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    1c78:	881e      	ldrh	r6, [r3, #0]
    1c7a:	428e      	cmp	r6, r1
    1c7c:	d1f9      	bne.n	1c72 <usb_isr+0x48a>
    1c7e:	885e      	ldrh	r6, [r3, #2]
    1c80:	4296      	cmp	r6, r2
    1c82:	d1f6      	bne.n	1c72 <usb_isr+0x48a>
				if ((setup.wValue >> 8) == 3) {
    1c84:	0a08      	lsrs	r0, r1, #8
    1c86:	2803      	cmp	r0, #3
					datalen = *(list->addr);
    1c88:	bf0c      	ite	eq
    1c8a:	782a      	ldrbeq	r2, [r5, #0]
					datalen = list->length;
    1c8c:	891a      	ldrhne	r2, [r3, #8]
	if (datalen > setup.wLength) datalen = setup.wLength;
    1c8e:	4b3e      	ldr	r3, [pc, #248]	; (1d88 <usb_isr+0x5a0>)
    1c90:	88df      	ldrh	r7, [r3, #6]
    1c92:	4297      	cmp	r7, r2
    1c94:	bf28      	it	cs
    1c96:	4617      	movcs	r7, r2
	if (size > EP0_SIZE) size = EP0_SIZE;
    1c98:	463e      	mov	r6, r7
    1c9a:	2f40      	cmp	r7, #64	; 0x40
    1c9c:	bf28      	it	cs
    1c9e:	2640      	movcs	r6, #64	; 0x40
	endpoint0_transmit(data, size);
    1ca0:	4631      	mov	r1, r6
    1ca2:	4628      	mov	r0, r5
    1ca4:	f7ff fcc0 	bl	1628 <endpoint0_transmit>
	data += size;
    1ca8:	4435      	add	r5, r6
	if (datalen == 0 && size < EP0_SIZE) return;
    1caa:	1bbe      	subs	r6, r7, r6
    1cac:	f47f af28 	bne.w	1b00 <usb_isr+0x318>
    1cb0:	2f3f      	cmp	r7, #63	; 0x3f
    1cb2:	f67f af35 	bls.w	1b20 <usb_isr+0x338>
	endpoint0_transmit(data, size);
    1cb6:	2100      	movs	r1, #0
    1cb8:	4628      	mov	r0, r5
    1cba:	f7ff fcb5 	bl	1628 <endpoint0_transmit>
	if (datalen == 0 && size < EP0_SIZE) return;
    1cbe:	e72f      	b.n	1b20 <usb_isr+0x338>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1cc0:	4b34      	ldr	r3, [pc, #208]	; (1d94 <usb_isr+0x5ac>)
    1cc2:	220f      	movs	r2, #15
    1cc4:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
}
    1cc8:	e72a      	b.n	1b20 <usb_isr+0x338>
	if (datalen == 0 && size < EP0_SIZE) return;
    1cca:	2e3f      	cmp	r6, #63	; 0x3f
    1ccc:	f63f af24 	bhi.w	1b18 <usb_isr+0x330>
    1cd0:	e726      	b.n	1b20 <usb_isr+0x338>
			switch (setup.wIndex) {
    1cd2:	4b2d      	ldr	r3, [pc, #180]	; (1d88 <usb_isr+0x5a0>)
    1cd4:	889b      	ldrh	r3, [r3, #4]
    1cd6:	b95b      	cbnz	r3, 1cf0 <usb_isr+0x508>
    1cd8:	4b37      	ldr	r3, [pc, #220]	; (1db8 <usb_isr+0x5d0>)
    1cda:	1dd0      	adds	r0, r2, #7
					*dst++ = *buf++;
    1cdc:	f812 1b01 	ldrb.w	r1, [r2], #1
    1ce0:	f803 1f01 	strb.w	r1, [r3, #1]!
				for (i=0; i<7; i++) {
    1ce4:	4282      	cmp	r2, r0
    1ce6:	d1f9      	bne.n	1cdc <usb_isr+0x4f4>
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    1ce8:	4b34      	ldr	r3, [pc, #208]	; (1dbc <usb_isr+0x5d4>)
    1cea:	681b      	ldr	r3, [r3, #0]
    1cec:	2b86      	cmp	r3, #134	; 0x86
    1cee:	d004      	beq.n	1cfa <usb_isr+0x512>
			endpoint0_transmit(NULL, 0);
    1cf0:	2100      	movs	r1, #0
    1cf2:	4608      	mov	r0, r1
    1cf4:	f7ff fc98 	bl	1628 <endpoint0_transmit>
    1cf8:	e598      	b.n	182c <usb_isr+0x44>
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    1cfa:	4b27      	ldr	r3, [pc, #156]	; (1d98 <usb_isr+0x5b0>)
    1cfc:	220f      	movs	r2, #15
    1cfe:	701a      	strb	r2, [r3, #0]
    1d00:	e7f6      	b.n	1cf0 <usb_isr+0x508>
		data = ep0_tx_ptr;
    1d02:	4b22      	ldr	r3, [pc, #136]	; (1d8c <usb_isr+0x5a4>)
    1d04:	681e      	ldr	r6, [r3, #0]
		if (data) {
    1d06:	b1b6      	cbz	r6, 1d36 <usb_isr+0x54e>
			size = ep0_tx_len;
    1d08:	f8df 8084 	ldr.w	r8, [pc, #132]	; 1d90 <usb_isr+0x5a8>
    1d0c:	f8b8 7000 	ldrh.w	r7, [r8]
			if (size > EP0_SIZE) size = EP0_SIZE;
    1d10:	463d      	mov	r5, r7
    1d12:	2f40      	cmp	r7, #64	; 0x40
    1d14:	bf28      	it	cs
    1d16:	2540      	movcs	r5, #64	; 0x40
			endpoint0_transmit(data, size);
    1d18:	4629      	mov	r1, r5
    1d1a:	4630      	mov	r0, r6
    1d1c:	f7ff fc84 	bl	1628 <endpoint0_transmit>
			data += size;
    1d20:	442e      	add	r6, r5
			ep0_tx_len -= size;
    1d22:	1b7d      	subs	r5, r7, r5
    1d24:	b2ad      	uxth	r5, r5
    1d26:	f8a8 5000 	strh.w	r5, [r8]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    1d2a:	b915      	cbnz	r5, 1d32 <usb_isr+0x54a>
    1d2c:	2f3f      	cmp	r7, #63	; 0x3f
    1d2e:	bf98      	it	ls
    1d30:	2600      	movls	r6, #0
    1d32:	4b16      	ldr	r3, [pc, #88]	; (1d8c <usb_isr+0x5a4>)
    1d34:	601e      	str	r6, [r3, #0]
		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    1d36:	4b14      	ldr	r3, [pc, #80]	; (1d88 <usb_isr+0x5a0>)
    1d38:	881b      	ldrh	r3, [r3, #0]
    1d3a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    1d3e:	f47f aef3 	bne.w	1b28 <usb_isr+0x340>
			setup.bRequest = 0;
    1d42:	4b11      	ldr	r3, [pc, #68]	; (1d88 <usb_isr+0x5a0>)
    1d44:	2200      	movs	r2, #0
    1d46:	705a      	strb	r2, [r3, #1]
			USB0_ADDR = setup.wValue;
    1d48:	789a      	ldrb	r2, [r3, #2]
    1d4a:	4b12      	ldr	r3, [pc, #72]	; (1d94 <usb_isr+0x5ac>)
    1d4c:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
    1d50:	e6ea      	b.n	1b28 <usb_isr+0x340>
				usb_free(packet);
    1d52:	f000 f969 	bl	2028 <usb_free>
				packet = tx_first[endpoint];
    1d56:	4b1a      	ldr	r3, [pc, #104]	; (1dc0 <usb_isr+0x5d8>)
    1d58:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
				if (packet) {
    1d5c:	2b00      	cmp	r3, #0
    1d5e:	d04d      	beq.n	1dfc <usb_isr+0x614>
					tx_first[endpoint] = packet->next;
    1d60:	6859      	ldr	r1, [r3, #4]
    1d62:	4a17      	ldr	r2, [pc, #92]	; (1dc0 <usb_isr+0x5d8>)
    1d64:	f842 1025 	str.w	r1, [r2, r5, lsl #2]
					b->addr = packet->buf;
    1d68:	f103 0208 	add.w	r2, r3, #8
    1d6c:	607a      	str	r2, [r7, #4]
					switch (tx_state[endpoint]) {
    1d6e:	4a15      	ldr	r2, [pc, #84]	; (1dc4 <usb_isr+0x5dc>)
    1d70:	5d52      	ldrb	r2, [r2, r5]
    1d72:	2a03      	cmp	r2, #3
    1d74:	d82b      	bhi.n	1dce <usb_isr+0x5e6>
    1d76:	e8df f002 	tbb	[pc, r2]
    1d7a:	3527      	.short	0x3527
    1d7c:	3d39      	.short	0x3d39
    1d7e:	bf00      	nop
    1d80:	1fff8c4c 	.word	0x1fff8c4c
    1d84:	1fff8bf8 	.word	0x1fff8bf8
    1d88:	1fff8c20 	.word	0x1fff8c20
    1d8c:	1fff8bf4 	.word	0x1fff8bf4
    1d90:	1fff8bf2 	.word	0x1fff8bf2
    1d94:	40072000 	.word	0x40072000
    1d98:	1fff8c4d 	.word	0x1fff8c4d
    1d9c:	1fff8c78 	.word	0x1fff8c78
    1da0:	1fff8c00 	.word	0x1fff8c00
    1da4:	1fff8c10 	.word	0x1fff8c10
    1da8:	1fff8c50 	.word	0x1fff8c50
    1dac:	004000c8 	.word	0x004000c8
    1db0:	00400088 	.word	0x00400088
    1db4:	00002a3c 	.word	0x00002a3c
    1db8:	1fff8c67 	.word	0x1fff8c67
    1dbc:	1fff8c68 	.word	0x1fff8c68
    1dc0:	1fff8c28 	.word	0x1fff8c28
    1dc4:	1fff8c48 	.word	0x1fff8c48
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    1dc8:	4a48      	ldr	r2, [pc, #288]	; (1eec <usb_isr+0x704>)
    1dca:	2103      	movs	r1, #3
    1dcc:	5551      	strb	r1, [r2, r5]
					b->desc = BDT_DESC(packet->len,
    1dce:	f017 0f08 	tst.w	r7, #8
    1dd2:	bf14      	ite	ne
    1dd4:	22c8      	movne	r2, #200	; 0xc8
    1dd6:	2288      	moveq	r2, #136	; 0x88
    1dd8:	881b      	ldrh	r3, [r3, #0]
    1dda:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
    1dde:	f844 3036 	str.w	r3, [r4, r6, lsl #3]
    1de2:	e6a5      	b.n	1b30 <usb_isr+0x348>
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    1de4:	4a41      	ldr	r2, [pc, #260]	; (1eec <usb_isr+0x704>)
    1de6:	2102      	movs	r1, #2
    1de8:	5551      	strb	r1, [r2, r5]
						break;
    1dea:	e7f0      	b.n	1dce <usb_isr+0x5e6>
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    1dec:	4a3f      	ldr	r2, [pc, #252]	; (1eec <usb_isr+0x704>)
    1dee:	2105      	movs	r1, #5
    1df0:	5551      	strb	r1, [r2, r5]
						break;
    1df2:	e7ec      	b.n	1dce <usb_isr+0x5e6>
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    1df4:	4a3d      	ldr	r2, [pc, #244]	; (1eec <usb_isr+0x704>)
    1df6:	2104      	movs	r1, #4
    1df8:	5551      	strb	r1, [r2, r5]
						break;
    1dfa:	e7e8      	b.n	1dce <usb_isr+0x5e6>
					switch (tx_state[endpoint]) {
    1dfc:	4b3b      	ldr	r3, [pc, #236]	; (1eec <usb_isr+0x704>)
    1dfe:	5d5b      	ldrb	r3, [r3, r5]
    1e00:	2b02      	cmp	r3, #2
    1e02:	d007      	beq.n	1e14 <usb_isr+0x62c>
    1e04:	f67f ae94 	bls.w	1b30 <usb_isr+0x348>
    1e08:	2b03      	cmp	r3, #3
    1e0a:	d107      	bne.n	1e1c <usb_isr+0x634>
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    1e0c:	4b37      	ldr	r3, [pc, #220]	; (1eec <usb_isr+0x704>)
    1e0e:	2201      	movs	r2, #1
    1e10:	555a      	strb	r2, [r3, r5]
						break;
    1e12:	e68d      	b.n	1b30 <usb_isr+0x348>
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    1e14:	4b35      	ldr	r3, [pc, #212]	; (1eec <usb_isr+0x704>)
    1e16:	2200      	movs	r2, #0
    1e18:	555a      	strb	r2, [r3, r5]
						break;
    1e1a:	e689      	b.n	1b30 <usb_isr+0x348>
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    1e1c:	f017 0f08 	tst.w	r7, #8
    1e20:	bf14      	ite	ne
    1e22:	2203      	movne	r2, #3
    1e24:	2202      	moveq	r2, #2
    1e26:	4b31      	ldr	r3, [pc, #196]	; (1eec <usb_isr+0x704>)
    1e28:	555a      	strb	r2, [r3, r5]
						break;
    1e2a:	e681      	b.n	1b30 <usb_isr+0x348>
						rx_first[endpoint] = packet;
    1e2c:	4b30      	ldr	r3, [pc, #192]	; (1ef0 <usb_isr+0x708>)
    1e2e:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
    1e32:	e6d5      	b.n	1be0 <usb_isr+0x3f8>
						b->desc = 0;
    1e34:	2300      	movs	r3, #0
    1e36:	f844 3036 	str.w	r3, [r4, r6, lsl #3]
						usb_rx_memory_needed++;
    1e3a:	4a2e      	ldr	r2, [pc, #184]	; (1ef4 <usb_isr+0x70c>)
    1e3c:	7813      	ldrb	r3, [r2, #0]
    1e3e:	3301      	adds	r3, #1
    1e40:	7013      	strb	r3, [r2, #0]
    1e42:	e675      	b.n	1b30 <usb_isr+0x348>
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    1e44:	f017 0f08 	tst.w	r7, #8
    1e48:	4b2b      	ldr	r3, [pc, #172]	; (1ef8 <usb_isr+0x710>)
    1e4a:	4a2c      	ldr	r2, [pc, #176]	; (1efc <usb_isr+0x714>)
    1e4c:	bf08      	it	eq
    1e4e:	4613      	moveq	r3, r2
    1e50:	f844 3036 	str.w	r3, [r4, r6, lsl #3]
    1e54:	e66c      	b.n	1b30 <usb_isr+0x348>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    1e56:	f015 0f01 	tst.w	r5, #1
    1e5a:	d116      	bne.n	1e8a <usb_isr+0x6a2>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    1e5c:	f015 0f80 	tst.w	r5, #128	; 0x80
    1e60:	d139      	bne.n	1ed6 <usb_isr+0x6ee>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    1e62:	f015 0f02 	tst.w	r5, #2
    1e66:	d008      	beq.n	1e7a <usb_isr+0x692>
		uint8_t err = USB0_ERRSTAT;
    1e68:	4b25      	ldr	r3, [pc, #148]	; (1f00 <usb_isr+0x718>)
    1e6a:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
    1e6e:	b2d2      	uxtb	r2, r2
		USB0_ERRSTAT = err;
    1e70:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    1e74:	2202      	movs	r2, #2
    1e76:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    1e7a:	f015 0f10 	tst.w	r5, #16
    1e7e:	d027      	beq.n	1ed0 <usb_isr+0x6e8>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    1e80:	4b1f      	ldr	r3, [pc, #124]	; (1f00 <usb_isr+0x718>)
    1e82:	2210      	movs	r2, #16
    1e84:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
    1e88:	e022      	b.n	1ed0 <usb_isr+0x6e8>
		USB0_CTL = USB_CTL_ODDRST;
    1e8a:	4b1d      	ldr	r3, [pc, #116]	; (1f00 <usb_isr+0x718>)
    1e8c:	2202      	movs	r2, #2
    1e8e:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
		ep0_tx_bdt_bank = 0;
    1e92:	2100      	movs	r1, #0
    1e94:	4a1b      	ldr	r2, [pc, #108]	; (1f04 <usb_isr+0x71c>)
    1e96:	7011      	strb	r1, [r2, #0]
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    1e98:	4a1b      	ldr	r2, [pc, #108]	; (1f08 <usb_isr+0x720>)
    1e9a:	4818      	ldr	r0, [pc, #96]	; (1efc <usb_isr+0x714>)
    1e9c:	6010      	str	r0, [r2, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    1e9e:	4c1b      	ldr	r4, [pc, #108]	; (1f0c <usb_isr+0x724>)
    1ea0:	6054      	str	r4, [r2, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    1ea2:	6090      	str	r0, [r2, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    1ea4:	481a      	ldr	r0, [pc, #104]	; (1f10 <usb_isr+0x728>)
    1ea6:	60d0      	str	r0, [r2, #12]
		table[index(0, TX, EVEN)].desc = 0;
    1ea8:	6111      	str	r1, [r2, #16]
		table[index(0, TX, ODD)].desc = 0;
    1eaa:	6191      	str	r1, [r2, #24]
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1eac:	220d      	movs	r2, #13
    1eae:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
		USB0_ERRSTAT = 0xFF;
    1eb2:	22ff      	movs	r2, #255	; 0xff
    1eb4:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
		USB0_ISTAT = 0xFF;
    1eb8:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
		USB0_ADDR = 0;
    1ebc:	f883 1098 	strb.w	r1, [r3, #152]	; 0x98
		USB0_ERREN = 0xFF;
    1ec0:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    1ec4:	229f      	movs	r2, #159	; 0x9f
    1ec6:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
		USB0_CTL = USB_CTL_USBENSOFEN;
    1eca:	2201      	movs	r2, #1
    1ecc:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
	}

}
    1ed0:	b005      	add	sp, #20
    1ed2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    1ed6:	4b0a      	ldr	r3, [pc, #40]	; (1f00 <usb_isr+0x718>)
    1ed8:	220d      	movs	r2, #13
    1eda:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
		USB0_ISTAT = USB_ISTAT_STALL;
    1ede:	2280      	movs	r2, #128	; 0x80
    1ee0:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
    1ee4:	e7bd      	b.n	1e62 <usb_isr+0x67a>
		datalen = 2;
    1ee6:	2202      	movs	r2, #2
    1ee8:	e5f9      	b.n	1ade <usb_isr+0x2f6>
    1eea:	bf00      	nop
    1eec:	1fff8c48 	.word	0x1fff8c48
    1ef0:	1fff8c00 	.word	0x1fff8c00
    1ef4:	1fff8c58 	.word	0x1fff8c58
    1ef8:	004000c8 	.word	0x004000c8
    1efc:	00400088 	.word	0x00400088
    1f00:	40072000 	.word	0x40072000
    1f04:	1fff8bf0 	.word	0x1fff8bf0
    1f08:	1fff8000 	.word	0x1fff8000
    1f0c:	1fff8b70 	.word	0x1fff8b70
    1f10:	1fff8bb0 	.word	0x1fff8bb0

00001f14 <usb_init>:



void usb_init(void)
{
    1f14:	b508      	push	{r3, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    1f16:	f000 fba5 	bl	2664 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    1f1a:	2300      	movs	r3, #0
		table[i].desc = 0;
    1f1c:	491b      	ldr	r1, [pc, #108]	; (1f8c <usb_init+0x78>)
    1f1e:	461a      	mov	r2, r3
    1f20:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
		table[i].addr = 0;
    1f24:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
    1f28:	6042      	str	r2, [r0, #4]
	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    1f2a:	3301      	adds	r3, #1
    1f2c:	2b14      	cmp	r3, #20
    1f2e:	d1f7      	bne.n	1f20 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    1f30:	4a17      	ldr	r2, [pc, #92]	; (1f90 <usb_init+0x7c>)
    1f32:	6b53      	ldr	r3, [r2, #52]	; 0x34
    1f34:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    1f38:	6353      	str	r3, [r2, #52]	; 0x34
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    1f3a:	4a14      	ldr	r2, [pc, #80]	; (1f8c <usb_init+0x78>)
    1f3c:	f3c2 2107 	ubfx	r1, r2, #8, #8
    1f40:	4b14      	ldr	r3, [pc, #80]	; (1f94 <usb_init+0x80>)
    1f42:	f883 109c 	strb.w	r1, [r3, #156]	; 0x9c
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    1f46:	f3c2 4107 	ubfx	r1, r2, #16, #8
    1f4a:	f883 10b0 	strb.w	r1, [r3, #176]	; 0xb0
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    1f4e:	0e12      	lsrs	r2, r2, #24
    1f50:	f883 20b4 	strb.w	r2, [r3, #180]	; 0xb4

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    1f54:	22ff      	movs	r2, #255	; 0xff
    1f56:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	USB0_ERRSTAT = 0xFF;
    1f5a:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
	USB0_OTGISTAT = 0xFF;
    1f5e:	741a      	strb	r2, [r3, #16]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    1f60:	2101      	movs	r1, #1
    1f62:	f883 1094 	strb.w	r1, [r3, #148]	; 0x94
	USB0_USBCTRL = 0;
    1f66:	4a0c      	ldr	r2, [pc, #48]	; (1f98 <usb_init+0x84>)
    1f68:	2000      	movs	r0, #0
    1f6a:	7010      	strb	r0, [r2, #0]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    1f6c:	f883 1084 	strb.w	r1, [r3, #132]	; 0x84

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    1f70:	4b0a      	ldr	r3, [pc, #40]	; (1f9c <usb_init+0x88>)
    1f72:	2170      	movs	r1, #112	; 0x70
    1f74:	f883 1049 	strb.w	r1, [r3, #73]	; 0x49
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    1f78:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1f7c:	f44f 7100 	mov.w	r1, #512	; 0x200
    1f80:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    1f84:	2310      	movs	r3, #16
    1f86:	7213      	strb	r3, [r2, #8]
}
    1f88:	bd08      	pop	{r3, pc}
    1f8a:	bf00      	nop
    1f8c:	1fff8000 	.word	0x1fff8000
    1f90:	40048000 	.word	0x40048000
    1f94:	40072000 	.word	0x40072000
    1f98:	40072100 	.word	0x40072100
    1f9c:	e000e400 	.word	0xe000e400

00001fa0 <usb_serial_class::clear()>:
        virtual void clear(void) { usb_serial_flush_input(); }
    1fa0:	b508      	push	{r3, lr}
    1fa2:	f000 f913 	bl	21cc <usb_serial_flush_input>
    1fa6:	bd08      	pop	{r3, pc}

00001fa8 <usb_serial_class::peek()>:
        virtual int peek() { return usb_serial_peekchar(); }
    1fa8:	b508      	push	{r3, lr}
    1faa:	f000 f891 	bl	20d0 <usb_serial_peekchar>
    1fae:	bd08      	pop	{r3, pc}

00001fb0 <usb_serial_class::read()>:
        virtual int read() { return usb_serial_getchar(); }
    1fb0:	b508      	push	{r3, lr}
    1fb2:	f000 f861 	bl	2078 <usb_serial_getchar>
    1fb6:	bd08      	pop	{r3, pc}

00001fb8 <usb_serial_class::available()>:
        virtual int available() { return usb_serial_available(); }
    1fb8:	b508      	push	{r3, lr}
    1fba:	f000 f8a7 	bl	210c <usb_serial_available>
    1fbe:	bd08      	pop	{r3, pc}

00001fc0 <usb_serial_class::flush()>:
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    1fc0:	b508      	push	{r3, lr}
    1fc2:	f000 f9cf 	bl	2364 <usb_serial_flush_output>
    1fc6:	bd08      	pop	{r3, pc}

00001fc8 <usb_serial_class::availableForWrite()>:
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    1fc8:	b508      	push	{r3, lr}
    1fca:	f000 f9a1 	bl	2310 <usb_serial_write_buffer_free>
    1fce:	bd08      	pop	{r3, pc}

00001fd0 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1fd0:	b508      	push	{r3, lr}
    1fd2:	4608      	mov	r0, r1
    1fd4:	4611      	mov	r1, r2
    1fd6:	f000 f915 	bl	2204 <usb_serial_write>
    1fda:	bd08      	pop	{r3, pc}

00001fdc <usb_serial_class::write(unsigned char)>:
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    1fdc:	b508      	push	{r3, lr}
    1fde:	4608      	mov	r0, r1
    1fe0:	f000 f98a 	bl	22f8 <usb_serial_putchar>
    1fe4:	bd08      	pop	{r3, pc}
    1fe6:	Address 0x0000000000001fe6 is out of bounds.


00001fe8 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    1fe8:	b672      	cpsid	i
	avail = usb_buffer_available;
    1fea:	4b0d      	ldr	r3, [pc, #52]	; (2020 <usb_malloc+0x38>)
    1fec:	681b      	ldr	r3, [r3, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    1fee:	fab3 f083 	clz	r0, r3
	if (n >= NUM_USB_BUFFERS) {
    1ff2:	280b      	cmp	r0, #11
    1ff4:	d811      	bhi.n	201a <usb_malloc+0x32>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    1ff6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    1ffa:	40c2      	lsrs	r2, r0
    1ffc:	ea23 0302 	bic.w	r3, r3, r2
    2000:	4a07      	ldr	r2, [pc, #28]	; (2020 <usb_malloc+0x38>)
    2002:	6013      	str	r3, [r2, #0]
	__enable_irq();
    2004:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    2006:	4a07      	ldr	r2, [pc, #28]	; (2024 <usb_malloc+0x3c>)
    2008:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
    200c:	00c1      	lsls	r1, r0, #3
    200e:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    2012:	2300      	movs	r3, #0
    2014:	5053      	str	r3, [r2, r1]
	*(uint32_t *)(p + 4) = 0;
    2016:	6043      	str	r3, [r0, #4]
	return (usb_packet_t *)p;
}
    2018:	4770      	bx	lr
		__enable_irq();
    201a:	b662      	cpsie	i
		return NULL;
    201c:	2000      	movs	r0, #0
    201e:	4770      	bx	lr
    2020:	1fff8934 	.word	0x1fff8934
    2024:	1fff85bc 	.word	0x1fff85bc

00002028 <usb_free>:
// for the receive endpoints to request memory
extern uint8_t usb_rx_memory_needed;
extern void usb_rx_memory(usb_packet_t *packet);

void usb_free(usb_packet_t *p)
{
    2028:	b508      	push	{r3, lr}
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    202a:	4b0e      	ldr	r3, [pc, #56]	; (2064 <usb_free+0x3c>)
    202c:	1ac3      	subs	r3, r0, r3
	if (n >= NUM_USB_BUFFERS) return;
    202e:	f5b3 7f58 	cmp.w	r3, #864	; 0x360
    2032:	d213      	bcs.n	205c <usb_free+0x34>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    2034:	4a0c      	ldr	r2, [pc, #48]	; (2068 <usb_free+0x40>)
    2036:	7812      	ldrb	r2, [r2, #0]
    2038:	b112      	cbz	r2, 2040 <usb_free+0x18>
    203a:	4a0c      	ldr	r2, [pc, #48]	; (206c <usb_free+0x44>)
    203c:	7812      	ldrb	r2, [r2, #0]
    203e:	b972      	cbnz	r2, 205e <usb_free+0x36>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    2040:	b672      	cpsid	i
	usb_buffer_available |= mask;
    2042:	490b      	ldr	r1, [pc, #44]	; (2070 <usb_free+0x48>)
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    2044:	4a0b      	ldr	r2, [pc, #44]	; (2074 <usb_free+0x4c>)
    2046:	fba2 2303 	umull	r2, r3, r2, r3
    204a:	091b      	lsrs	r3, r3, #4
	mask = (0x80000000 >> n);
    204c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    2050:	fa22 f303 	lsr.w	r3, r2, r3
	usb_buffer_available |= mask;
    2054:	680a      	ldr	r2, [r1, #0]
    2056:	4313      	orrs	r3, r2
    2058:	600b      	str	r3, [r1, #0]
	__enable_irq();
    205a:	b662      	cpsie	i

	//serial_print("free:");
	//serial_phex32((int)p);
	//serial_print("\n");
}
    205c:	bd08      	pop	{r3, pc}
		usb_rx_memory(p);
    205e:	f7ff fb37 	bl	16d0 <usb_rx_memory>
		return;
    2062:	e7fb      	b.n	205c <usb_free+0x34>
    2064:	1fff85bc 	.word	0x1fff85bc
    2068:	1fff8c58 	.word	0x1fff8c58
    206c:	1fff8c4c 	.word	0x1fff8c4c
    2070:	1fff8934 	.word	0x1fff8934
    2074:	38e38e39 	.word	0x38e38e39

00002078 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    2078:	b510      	push	{r4, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    207a:	4b13      	ldr	r3, [pc, #76]	; (20c8 <usb_serial_getchar+0x50>)
    207c:	681b      	ldr	r3, [r3, #0]
    207e:	b163      	cbz	r3, 209a <usb_serial_getchar+0x22>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    2080:	4b11      	ldr	r3, [pc, #68]	; (20c8 <usb_serial_getchar+0x50>)
    2082:	6818      	ldr	r0, [r3, #0]
    2084:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    2086:	18c2      	adds	r2, r0, r3
    2088:	7a14      	ldrb	r4, [r2, #8]
	if (i >= rx_packet->len) {
    208a:	8801      	ldrh	r1, [r0, #0]
	c = rx_packet->buf[i++];
    208c:	1c5a      	adds	r2, r3, #1
	if (i >= rx_packet->len) {
    208e:	4291      	cmp	r1, r2
    2090:	d910      	bls.n	20b4 <usb_serial_getchar+0x3c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    2092:	3301      	adds	r3, #1
    2094:	8043      	strh	r3, [r0, #2]
	}
	return c;
}
    2096:	4620      	mov	r0, r4
    2098:	bd10      	pop	{r4, pc}
		if (!usb_configuration) return -1;
    209a:	4b0c      	ldr	r3, [pc, #48]	; (20cc <usb_serial_getchar+0x54>)
    209c:	781b      	ldrb	r3, [r3, #0]
    209e:	b17b      	cbz	r3, 20c0 <usb_serial_getchar+0x48>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    20a0:	2003      	movs	r0, #3
    20a2:	f7ff fae3 	bl	166c <usb_rx>
    20a6:	4b08      	ldr	r3, [pc, #32]	; (20c8 <usb_serial_getchar+0x50>)
    20a8:	6018      	str	r0, [r3, #0]
		if (!rx_packet) return -1;
    20aa:	2800      	cmp	r0, #0
    20ac:	d1e8      	bne.n	2080 <usb_serial_getchar+0x8>
    20ae:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    20b2:	e7f0      	b.n	2096 <usb_serial_getchar+0x1e>
		usb_free(rx_packet);
    20b4:	f7ff ffb8 	bl	2028 <usb_free>
		rx_packet = NULL;
    20b8:	4b03      	ldr	r3, [pc, #12]	; (20c8 <usb_serial_getchar+0x50>)
    20ba:	2200      	movs	r2, #0
    20bc:	601a      	str	r2, [r3, #0]
    20be:	e7ea      	b.n	2096 <usb_serial_getchar+0x1e>
		if (!usb_configuration) return -1;
    20c0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    20c4:	e7e7      	b.n	2096 <usb_serial_getchar+0x1e>
    20c6:	bf00      	nop
    20c8:	1fff8c5c 	.word	0x1fff8c5c
    20cc:	1fff8c4c 	.word	0x1fff8c4c

000020d0 <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    20d0:	b508      	push	{r3, lr}
	if (!rx_packet) {
    20d2:	4b0c      	ldr	r3, [pc, #48]	; (2104 <usb_serial_peekchar+0x34>)
    20d4:	681b      	ldr	r3, [r3, #0]
    20d6:	b12b      	cbz	r3, 20e4 <usb_serial_peekchar+0x14>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    20d8:	4b0a      	ldr	r3, [pc, #40]	; (2104 <usb_serial_peekchar+0x34>)
    20da:	681b      	ldr	r3, [r3, #0]
	return rx_packet->buf[rx_packet->index];
    20dc:	885a      	ldrh	r2, [r3, #2]
    20de:	4413      	add	r3, r2
    20e0:	7a18      	ldrb	r0, [r3, #8]
}
    20e2:	bd08      	pop	{r3, pc}
		if (!usb_configuration) return -1;
    20e4:	4b08      	ldr	r3, [pc, #32]	; (2108 <usb_serial_peekchar+0x38>)
    20e6:	781b      	ldrb	r3, [r3, #0]
    20e8:	b14b      	cbz	r3, 20fe <usb_serial_peekchar+0x2e>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    20ea:	2003      	movs	r0, #3
    20ec:	f7ff fabe 	bl	166c <usb_rx>
    20f0:	4b04      	ldr	r3, [pc, #16]	; (2104 <usb_serial_peekchar+0x34>)
    20f2:	6018      	str	r0, [r3, #0]
		if (!rx_packet) return -1;
    20f4:	2800      	cmp	r0, #0
    20f6:	d1ef      	bne.n	20d8 <usb_serial_peekchar+0x8>
    20f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    20fc:	e7f1      	b.n	20e2 <usb_serial_peekchar+0x12>
		if (!usb_configuration) return -1;
    20fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2102:	e7ee      	b.n	20e2 <usb_serial_peekchar+0x12>
    2104:	1fff8c5c 	.word	0x1fff8c5c
    2108:	1fff8c4c 	.word	0x1fff8c4c

0000210c <usb_serial_available>:

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
    210c:	b510      	push	{r4, lr}
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    210e:	4b07      	ldr	r3, [pc, #28]	; (212c <usb_serial_available+0x20>)
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    2110:	889c      	ldrh	r4, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    2112:	4b07      	ldr	r3, [pc, #28]	; (2130 <usb_serial_available+0x24>)
    2114:	681b      	ldr	r3, [r3, #0]
    2116:	b11b      	cbz	r3, 2120 <usb_serial_available+0x14>
    2118:	881a      	ldrh	r2, [r3, #0]
    211a:	885b      	ldrh	r3, [r3, #2]
    211c:	1ad3      	subs	r3, r2, r3
    211e:	441c      	add	r4, r3
	if (count == 0) yield();
    2120:	b10c      	cbz	r4, 2126 <usb_serial_available+0x1a>
	return count;
}
    2122:	4620      	mov	r0, r4
    2124:	bd10      	pop	{r4, pc}
	if (count == 0) yield();
    2126:	f000 f96f 	bl	2408 <yield>
	return count;
    212a:	e7fa      	b.n	2122 <usb_serial_available+0x16>
    212c:	1fff8c50 	.word	0x1fff8c50
    2130:	1fff8c5c 	.word	0x1fff8c5c

00002134 <usb_serial_read>:

// read a block of bytes to a buffer
int usb_serial_read(void *buffer, uint32_t size)
{
    2134:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t *p = (uint8_t *)buffer;
	uint32_t qty, count=0;

	while (size) {
    2138:	460d      	mov	r5, r1
    213a:	2900      	cmp	r1, #0
    213c:	d03e      	beq.n	21bc <usb_serial_read+0x88>
    213e:	4606      	mov	r6, r0
	uint32_t qty, count=0;
    2140:	f04f 0800 	mov.w	r8, #0
		if (!usb_configuration) break;
    2144:	f8df 907c 	ldr.w	r9, [pc, #124]	; 21c4 <usb_serial_read+0x90>
		if (!rx_packet) {
    2148:	4c1f      	ldr	r4, [pc, #124]	; (21c8 <usb_serial_read+0x94>)
			rx:
			rx_packet = usb_rx(CDC_RX_ENDPOINT);
    214a:	2703      	movs	r7, #3
    214c:	e00a      	b.n	2164 <usb_serial_read+0x30>
    214e:	4638      	mov	r0, r7
    2150:	f7ff fa8c 	bl	166c <usb_rx>
    2154:	6020      	str	r0, [r4, #0]
			if (!rx_packet) break;
    2156:	b390      	cbz	r0, 21be <usb_serial_read+0x8a>
			if (rx_packet->len == 0) {
    2158:	8803      	ldrh	r3, [r0, #0]
    215a:	b94b      	cbnz	r3, 2170 <usb_serial_read+0x3c>
				usb_free(rx_packet);
    215c:	f7ff ff64 	bl	2028 <usb_free>
				goto rx;
    2160:	e7f5      	b.n	214e <usb_serial_read+0x1a>
	while (size) {
    2162:	b365      	cbz	r5, 21be <usb_serial_read+0x8a>
		if (!usb_configuration) break;
    2164:	f899 3000 	ldrb.w	r3, [r9]
    2168:	b34b      	cbz	r3, 21be <usb_serial_read+0x8a>
		if (!rx_packet) {
    216a:	6823      	ldr	r3, [r4, #0]
    216c:	2b00      	cmp	r3, #0
    216e:	d0ee      	beq.n	214e <usb_serial_read+0x1a>
			}
		}
		qty = rx_packet->len - rx_packet->index;
    2170:	f8d4 b000 	ldr.w	fp, [r4]
    2174:	f8bb 1002 	ldrh.w	r1, [fp, #2]
    2178:	465b      	mov	r3, fp
    217a:	f833 ab08 	ldrh.w	sl, [r3], #8
    217e:	ebaa 0a01 	sub.w	sl, sl, r1
    2182:	45aa      	cmp	sl, r5
    2184:	bf28      	it	cs
    2186:	46aa      	movcs	sl, r5
		if (qty > size) qty = size;
		memcpy(p, rx_packet->buf + rx_packet->index, qty);
    2188:	4652      	mov	r2, sl
    218a:	4419      	add	r1, r3
    218c:	4630      	mov	r0, r6
    218e:	f7ff f85b 	bl	1248 <memcpy>
		p += qty;
    2192:	4456      	add	r6, sl
		count += qty;
    2194:	44d0      	add	r8, sl
		size -= qty;
    2196:	eba5 050a 	sub.w	r5, r5, sl
		rx_packet->index += qty;
    219a:	f8bb 3002 	ldrh.w	r3, [fp, #2]
    219e:	449a      	add	sl, r3
    21a0:	fa1f fa8a 	uxth.w	sl, sl
    21a4:	f8ab a002 	strh.w	sl, [fp, #2]
		if (rx_packet->index >= rx_packet->len) {
    21a8:	f8bb 3000 	ldrh.w	r3, [fp]
    21ac:	4553      	cmp	r3, sl
    21ae:	d8d8      	bhi.n	2162 <usb_serial_read+0x2e>
			usb_free(rx_packet);
    21b0:	4658      	mov	r0, fp
    21b2:	f7ff ff39 	bl	2028 <usb_free>
			rx_packet = NULL;
    21b6:	2300      	movs	r3, #0
    21b8:	6023      	str	r3, [r4, #0]
    21ba:	e7d2      	b.n	2162 <usb_serial_read+0x2e>
	uint32_t qty, count=0;
    21bc:	4688      	mov	r8, r1
		}
	}
	return count;
}
    21be:	4640      	mov	r0, r8
    21c0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    21c4:	1fff8c4c 	.word	0x1fff8c4c
    21c8:	1fff8c5c 	.word	0x1fff8c5c

000021cc <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    21cc:	4b0b      	ldr	r3, [pc, #44]	; (21fc <usb_serial_flush_input+0x30>)
    21ce:	781b      	ldrb	r3, [r3, #0]
    21d0:	b193      	cbz	r3, 21f8 <usb_serial_flush_input+0x2c>
{
    21d2:	b510      	push	{r4, lr}
	if (rx_packet) {
    21d4:	4b0a      	ldr	r3, [pc, #40]	; (2200 <usb_serial_flush_input+0x34>)
    21d6:	6818      	ldr	r0, [r3, #0]
    21d8:	b120      	cbz	r0, 21e4 <usb_serial_flush_input+0x18>
		usb_free(rx_packet);
    21da:	f7ff ff25 	bl	2028 <usb_free>
		rx_packet = NULL;
    21de:	4b08      	ldr	r3, [pc, #32]	; (2200 <usb_serial_flush_input+0x34>)
    21e0:	2200      	movs	r2, #0
    21e2:	601a      	str	r2, [r3, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    21e4:	2403      	movs	r4, #3
    21e6:	e001      	b.n	21ec <usb_serial_flush_input+0x20>
		if (!rx) break;
		usb_free(rx);
    21e8:	f7ff ff1e 	bl	2028 <usb_free>
		rx = usb_rx(CDC_RX_ENDPOINT);
    21ec:	4620      	mov	r0, r4
    21ee:	f7ff fa3d 	bl	166c <usb_rx>
		if (!rx) break;
    21f2:	2800      	cmp	r0, #0
    21f4:	d1f8      	bne.n	21e8 <usb_serial_flush_input+0x1c>
	}
}
    21f6:	bd10      	pop	{r4, pc}
    21f8:	4770      	bx	lr
    21fa:	bf00      	nop
    21fc:	1fff8c4c 	.word	0x1fff8c4c
    2200:	1fff8c5c 	.word	0x1fff8c5c

00002204 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    2204:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    2208:	4b36      	ldr	r3, [pc, #216]	; (22e4 <usb_serial_write+0xe0>)
    220a:	2201      	movs	r2, #1
    220c:	701a      	strb	r2, [r3, #0]
	while (size > 0) {
    220e:	468a      	mov	sl, r1
    2210:	2900      	cmp	r1, #0
    2212:	d062      	beq.n	22da <usb_serial_write+0xd6>
    2214:	4604      	mov	r4, r0
    2216:	460d      	mov	r5, r1
		if (!tx_packet) {
    2218:	4e33      	ldr	r6, [pc, #204]	; (22e8 <usb_serial_write+0xe4>)
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    221a:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 22ec <usb_serial_write+0xe8>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    221e:	4699      	mov	r9, r3
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    2220:	4f33      	ldr	r7, [pc, #204]	; (22f0 <usb_serial_write+0xec>)
    2222:	e031      	b.n	2288 <usb_serial_write+0x84>
				if (!usb_configuration) {
    2224:	f898 3000 	ldrb.w	r3, [r8]
    2228:	b113      	cbz	r3, 2230 <usb_serial_write+0x2c>
    222a:	f648 4b01 	movw	fp, #35841	; 0x8c01
    222e:	e010      	b.n	2252 <usb_serial_write+0x4e>
					tx_noautoflush = 0;
    2230:	4b2c      	ldr	r3, [pc, #176]	; (22e4 <usb_serial_write+0xe0>)
    2232:	2200      	movs	r2, #0
    2234:	701a      	strb	r2, [r3, #0]
					return -1;
    2236:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    223a:	e01f      	b.n	227c <usb_serial_write+0x78>
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    223c:	f1bb 0b01 	subs.w	fp, fp, #1
    2240:	d017      	beq.n	2272 <usb_serial_write+0x6e>
    2242:	783b      	ldrb	r3, [r7, #0]
    2244:	b9ab      	cbnz	r3, 2272 <usb_serial_write+0x6e>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    2246:	f000 f8df 	bl	2408 <yield>
				if (!usb_configuration) {
    224a:	f898 3000 	ldrb.w	r3, [r8]
    224e:	2b00      	cmp	r3, #0
    2250:	d0ee      	beq.n	2230 <usb_serial_write+0x2c>
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    2252:	2004      	movs	r0, #4
    2254:	f7ff fa26 	bl	16a4 <usb_tx_packet_count>
    2258:	2807      	cmp	r0, #7
    225a:	d8ef      	bhi.n	223c <usb_serial_write+0x38>
					tx_noautoflush = 1;
    225c:	2301      	movs	r3, #1
    225e:	f889 3000 	strb.w	r3, [r9]
					tx_packet = usb_malloc();
    2262:	f7ff fec1 	bl	1fe8 <usb_malloc>
    2266:	6030      	str	r0, [r6, #0]
					if (tx_packet) break;
    2268:	b988      	cbnz	r0, 228e <usb_serial_write+0x8a>
					tx_noautoflush = 0;
    226a:	2300      	movs	r3, #0
    226c:	f889 3000 	strb.w	r3, [r9]
    2270:	e7e4      	b.n	223c <usb_serial_write+0x38>
					transmit_previous_timeout = 1;
    2272:	4b1f      	ldr	r3, [pc, #124]	; (22f0 <usb_serial_write+0xec>)
    2274:	2201      	movs	r2, #1
    2276:	701a      	strb	r2, [r3, #0]
					return -1;
    2278:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    227c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    2280:	4b1c      	ldr	r3, [pc, #112]	; (22f4 <usb_serial_write+0xf0>)
    2282:	2205      	movs	r2, #5
    2284:	701a      	strb	r2, [r3, #0]
	while (size > 0) {
    2286:	b345      	cbz	r5, 22da <usb_serial_write+0xd6>
		if (!tx_packet) {
    2288:	6833      	ldr	r3, [r6, #0]
    228a:	2b00      	cmp	r3, #0
    228c:	d0ca      	beq.n	2224 <usb_serial_write+0x20>
		transmit_previous_timeout = 0;
    228e:	2300      	movs	r3, #0
    2290:	703b      	strb	r3, [r7, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    2292:	6831      	ldr	r1, [r6, #0]
    2294:	8848      	ldrh	r0, [r1, #2]
    2296:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
    229a:	42aa      	cmp	r2, r5
    229c:	bf28      	it	cs
    229e:	462a      	movcs	r2, r5
		dest = tx_packet->buf + tx_packet->index;
    22a0:	f101 0308 	add.w	r3, r1, #8
		tx_packet->index += len;
    22a4:	eb00 0c02 	add.w	ip, r0, r2
    22a8:	f8a1 c002 	strh.w	ip, [r1, #2]
		size -= len;
    22ac:	1aad      	subs	r5, r5, r2
		while (len-- > 0) *dest++ = *src++;
    22ae:	b14a      	cbz	r2, 22c4 <usb_serial_write+0xc0>
    22b0:	3801      	subs	r0, #1
    22b2:	4403      	add	r3, r0
    22b4:	4422      	add	r2, r4
    22b6:	f814 0b01 	ldrb.w	r0, [r4], #1
    22ba:	f803 0f01 	strb.w	r0, [r3, #1]!
    22be:	4294      	cmp	r4, r2
    22c0:	d1f9      	bne.n	22b6 <usb_serial_write+0xb2>
    22c2:	4614      	mov	r4, r2
		if (tx_packet->index >= CDC_TX_SIZE) {
    22c4:	884b      	ldrh	r3, [r1, #2]
    22c6:	2b3f      	cmp	r3, #63	; 0x3f
    22c8:	d9da      	bls.n	2280 <usb_serial_write+0x7c>
			tx_packet->len = CDC_TX_SIZE;
    22ca:	2340      	movs	r3, #64	; 0x40
    22cc:	800b      	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    22ce:	2004      	movs	r0, #4
    22d0:	f7ff fa44 	bl	175c <usb_tx>
			tx_packet = NULL;
    22d4:	2300      	movs	r3, #0
    22d6:	6033      	str	r3, [r6, #0]
    22d8:	e7d2      	b.n	2280 <usb_serial_write+0x7c>
	tx_noautoflush = 0;
    22da:	4b02      	ldr	r3, [pc, #8]	; (22e4 <usb_serial_write+0xe0>)
    22dc:	2200      	movs	r2, #0
    22de:	701a      	strb	r2, [r3, #0]
	return ret;
    22e0:	4650      	mov	r0, sl
    22e2:	e7cb      	b.n	227c <usb_serial_write+0x78>
    22e4:	1fff8c61 	.word	0x1fff8c61
    22e8:	1fff8c64 	.word	0x1fff8c64
    22ec:	1fff8c4c 	.word	0x1fff8c4c
    22f0:	1fff8c60 	.word	0x1fff8c60
    22f4:	1fff8c78 	.word	0x1fff8c78

000022f8 <usb_serial_putchar>:
{
    22f8:	b500      	push	{lr}
    22fa:	b083      	sub	sp, #12
    22fc:	f88d 0007 	strb.w	r0, [sp, #7]
	return usb_serial_write(&c, 1);
    2300:	2101      	movs	r1, #1
    2302:	f10d 0007 	add.w	r0, sp, #7
    2306:	f7ff ff7d 	bl	2204 <usb_serial_write>
}
    230a:	b003      	add	sp, #12
    230c:	f85d fb04 	ldr.w	pc, [sp], #4

00002310 <usb_serial_write_buffer_free>:

int usb_serial_write_buffer_free(void)
{
    2310:	b508      	push	{r3, lr}
	uint32_t len;

	tx_noautoflush = 1;
    2312:	4b11      	ldr	r3, [pc, #68]	; (2358 <usb_serial_write_buffer_free+0x48>)
    2314:	2201      	movs	r2, #1
    2316:	701a      	strb	r2, [r3, #0]
	if (!tx_packet) {
    2318:	4b10      	ldr	r3, [pc, #64]	; (235c <usb_serial_write_buffer_free+0x4c>)
    231a:	681b      	ldr	r3, [r3, #0]
    231c:	b143      	cbz	r3, 2330 <usb_serial_write_buffer_free+0x20>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    231e:	4b0f      	ldr	r3, [pc, #60]	; (235c <usb_serial_write_buffer_free+0x4c>)
    2320:	681b      	ldr	r3, [r3, #0]
    2322:	8858      	ldrh	r0, [r3, #2]
    2324:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    2328:	4b0b      	ldr	r3, [pc, #44]	; (2358 <usb_serial_write_buffer_free+0x48>)
    232a:	2200      	movs	r2, #0
    232c:	701a      	strb	r2, [r3, #0]
	return len;
}
    232e:	bd08      	pop	{r3, pc}
		if (!usb_configuration ||
    2330:	4b0b      	ldr	r3, [pc, #44]	; (2360 <usb_serial_write_buffer_free+0x50>)
    2332:	781b      	ldrb	r3, [r3, #0]
    2334:	b91b      	cbnz	r3, 233e <usb_serial_write_buffer_free+0x2e>
			tx_noautoflush = 0;
    2336:	2000      	movs	r0, #0
    2338:	4b07      	ldr	r3, [pc, #28]	; (2358 <usb_serial_write_buffer_free+0x48>)
    233a:	7018      	strb	r0, [r3, #0]
			return 0;
    233c:	e7f7      	b.n	232e <usb_serial_write_buffer_free+0x1e>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    233e:	2004      	movs	r0, #4
    2340:	f7ff f9b0 	bl	16a4 <usb_tx_packet_count>
		if (!usb_configuration ||
    2344:	2807      	cmp	r0, #7
    2346:	d8f6      	bhi.n	2336 <usb_serial_write_buffer_free+0x26>
		  (tx_packet = usb_malloc()) == NULL) {
    2348:	f7ff fe4e 	bl	1fe8 <usb_malloc>
    234c:	4b03      	ldr	r3, [pc, #12]	; (235c <usb_serial_write_buffer_free+0x4c>)
    234e:	6018      	str	r0, [r3, #0]
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    2350:	2800      	cmp	r0, #0
    2352:	d1e4      	bne.n	231e <usb_serial_write_buffer_free+0xe>
    2354:	e7ef      	b.n	2336 <usb_serial_write_buffer_free+0x26>
    2356:	bf00      	nop
    2358:	1fff8c61 	.word	0x1fff8c61
    235c:	1fff8c64 	.word	0x1fff8c64
    2360:	1fff8c4c 	.word	0x1fff8c4c

00002364 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
    2364:	4b13      	ldr	r3, [pc, #76]	; (23b4 <usb_serial_flush_output+0x50>)
    2366:	781b      	ldrb	r3, [r3, #0]
    2368:	b31b      	cbz	r3, 23b2 <usb_serial_flush_output+0x4e>
{
    236a:	b510      	push	{r4, lr}
	tx_noautoflush = 1;
    236c:	4b12      	ldr	r3, [pc, #72]	; (23b8 <usb_serial_flush_output+0x54>)
    236e:	2201      	movs	r2, #1
    2370:	701a      	strb	r2, [r3, #0]
	if (tx_packet) {
    2372:	4b12      	ldr	r3, [pc, #72]	; (23bc <usb_serial_flush_output+0x58>)
    2374:	6819      	ldr	r1, [r3, #0]
    2376:	b169      	cbz	r1, 2394 <usb_serial_flush_output+0x30>
		usb_cdc_transmit_flush_timer = 0;
    2378:	2400      	movs	r4, #0
    237a:	4b11      	ldr	r3, [pc, #68]	; (23c0 <usb_serial_flush_output+0x5c>)
    237c:	701c      	strb	r4, [r3, #0]
		tx_packet->len = tx_packet->index;
    237e:	884b      	ldrh	r3, [r1, #2]
    2380:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    2382:	2004      	movs	r0, #4
    2384:	f7ff f9ea 	bl	175c <usb_tx>
		tx_packet = NULL;
    2388:	4b0c      	ldr	r3, [pc, #48]	; (23bc <usb_serial_flush_output+0x58>)
    238a:	601c      	str	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    238c:	4b0a      	ldr	r3, [pc, #40]	; (23b8 <usb_serial_flush_output+0x54>)
    238e:	2200      	movs	r2, #0
    2390:	701a      	strb	r2, [r3, #0]
}
    2392:	bd10      	pop	{r4, pc}
		usb_packet_t *tx = usb_malloc();
    2394:	f7ff fe28 	bl	1fe8 <usb_malloc>
		if (tx) {
    2398:	4601      	mov	r1, r0
    239a:	b130      	cbz	r0, 23aa <usb_serial_flush_output+0x46>
			usb_cdc_transmit_flush_timer = 0;
    239c:	4b08      	ldr	r3, [pc, #32]	; (23c0 <usb_serial_flush_output+0x5c>)
    239e:	2200      	movs	r2, #0
    23a0:	701a      	strb	r2, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    23a2:	2004      	movs	r0, #4
    23a4:	f7ff f9da 	bl	175c <usb_tx>
    23a8:	e7f0      	b.n	238c <usb_serial_flush_output+0x28>
			usb_cdc_transmit_flush_timer = 1;
    23aa:	4b05      	ldr	r3, [pc, #20]	; (23c0 <usb_serial_flush_output+0x5c>)
    23ac:	2201      	movs	r2, #1
    23ae:	701a      	strb	r2, [r3, #0]
    23b0:	e7ec      	b.n	238c <usb_serial_flush_output+0x28>
    23b2:	4770      	bx	lr
    23b4:	1fff8c4c 	.word	0x1fff8c4c
    23b8:	1fff8c61 	.word	0x1fff8c61
    23bc:	1fff8c64 	.word	0x1fff8c64
    23c0:	1fff8c78 	.word	0x1fff8c78

000023c4 <usb_serial_flush_callback>:

void usb_serial_flush_callback(void)
{
    23c4:	b508      	push	{r3, lr}
	if (tx_noautoflush) return;
    23c6:	4b0d      	ldr	r3, [pc, #52]	; (23fc <usb_serial_flush_callback+0x38>)
    23c8:	781b      	ldrb	r3, [r3, #0]
    23ca:	b953      	cbnz	r3, 23e2 <usb_serial_flush_callback+0x1e>
	if (tx_packet) {
    23cc:	4b0c      	ldr	r3, [pc, #48]	; (2400 <usb_serial_flush_callback+0x3c>)
    23ce:	6819      	ldr	r1, [r3, #0]
    23d0:	b141      	cbz	r1, 23e4 <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
    23d2:	884b      	ldrh	r3, [r1, #2]
    23d4:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    23d6:	2004      	movs	r0, #4
    23d8:	f7ff f9c0 	bl	175c <usb_tx>
		tx_packet = NULL;
    23dc:	4b08      	ldr	r3, [pc, #32]	; (2400 <usb_serial_flush_callback+0x3c>)
    23de:	2200      	movs	r2, #0
    23e0:	601a      	str	r2, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    23e2:	bd08      	pop	{r3, pc}
		usb_packet_t *tx = usb_malloc();
    23e4:	f7ff fe00 	bl	1fe8 <usb_malloc>
		if (tx) {
    23e8:	4601      	mov	r1, r0
    23ea:	b118      	cbz	r0, 23f4 <usb_serial_flush_callback+0x30>
			usb_tx(CDC_TX_ENDPOINT, tx);
    23ec:	2004      	movs	r0, #4
    23ee:	f7ff f9b5 	bl	175c <usb_tx>
    23f2:	e7f6      	b.n	23e2 <usb_serial_flush_callback+0x1e>
			usb_cdc_transmit_flush_timer = 1;
    23f4:	4b03      	ldr	r3, [pc, #12]	; (2404 <usb_serial_flush_callback+0x40>)
    23f6:	2201      	movs	r2, #1
    23f8:	701a      	strb	r2, [r3, #0]
    23fa:	e7f2      	b.n	23e2 <usb_serial_flush_callback+0x1e>
    23fc:	1fff8c61 	.word	0x1fff8c61
    2400:	1fff8c64 	.word	0x1fff8c64
    2404:	1fff8c78 	.word	0x1fff8c78

00002408 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    2408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    240a:	4b39      	ldr	r3, [pc, #228]	; (24f0 <yield+0xe8>)
    240c:	781b      	ldrb	r3, [r3, #0]
    240e:	b1ab      	cbz	r3, 243c <yield+0x34>
	if (running) return; // TODO: does this need to be atomic?
    2410:	4a38      	ldr	r2, [pc, #224]	; (24f4 <yield+0xec>)
    2412:	7812      	ldrb	r2, [r2, #0]
    2414:	b992      	cbnz	r2, 243c <yield+0x34>
	running = 1;
    2416:	4a37      	ldr	r2, [pc, #220]	; (24f4 <yield+0xec>)
    2418:	2101      	movs	r1, #1
    241a:	7011      	strb	r1, [r2, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    241c:	f013 0f01 	tst.w	r3, #1
    2420:	d10d      	bne.n	243e <yield+0x36>
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    2422:	4b33      	ldr	r3, [pc, #204]	; (24f0 <yield+0xe8>)
    2424:	781b      	ldrb	r3, [r3, #0]
    2426:	f013 0f02 	tst.w	r3, #2
    242a:	d118      	bne.n	245e <yield+0x56>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    242c:	4b31      	ldr	r3, [pc, #196]	; (24f4 <yield+0xec>)
    242e:	2200      	movs	r2, #0
    2430:	701a      	strb	r2, [r3, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    2432:	4b2f      	ldr	r3, [pc, #188]	; (24f0 <yield+0xe8>)
    2434:	781b      	ldrb	r3, [r3, #0]
    2436:	f013 0f04 	tst.w	r3, #4
    243a:	d129      	bne.n	2490 <yield+0x88>
	
};
    243c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        virtual int available() { return usb_serial_available(); }
    243e:	f7ff fe65 	bl	210c <usb_serial_available>
		if (Serial.available()) serialEvent();
    2442:	b948      	cbnz	r0, 2458 <yield+0x50>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    2444:	4b2c      	ldr	r3, [pc, #176]	; (24f8 <yield+0xf0>)
    2446:	781b      	ldrb	r3, [r3, #0]
    2448:	2b00      	cmp	r3, #0
    244a:	d0ea      	beq.n	2422 <yield+0x1a>
    244c:	4a28      	ldr	r2, [pc, #160]	; (24f0 <yield+0xe8>)
    244e:	7813      	ldrb	r3, [r2, #0]
    2450:	f023 0301 	bic.w	r3, r3, #1
    2454:	7013      	strb	r3, [r2, #0]
    2456:	e7e4      	b.n	2422 <yield+0x1a>
		if (Serial.available()) serialEvent();
    2458:	f000 f902 	bl	2660 <serialEvent()>
    245c:	e7f2      	b.n	2444 <yield+0x3c>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    245e:	4b27      	ldr	r3, [pc, #156]	; (24fc <yield+0xf4>)
    2460:	781b      	ldrb	r3, [r3, #0]
    2462:	2b00      	cmp	r3, #0
    2464:	d0e2      	beq.n	242c <yield+0x24>
    2466:	2400      	movs	r4, #0
			s_serials_with_serial_events[i]->doYieldCode();
    2468:	4f25      	ldr	r7, [pc, #148]	; (2500 <yield+0xf8>)
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    246a:	4e24      	ldr	r6, [pc, #144]	; (24fc <yield+0xf4>)
    246c:	e004      	b.n	2478 <yield+0x70>
    246e:	3401      	adds	r4, #1
    2470:	7832      	ldrb	r2, [r6, #0]
    2472:	b2e3      	uxtb	r3, r4
    2474:	429a      	cmp	r2, r3
    2476:	d9d9      	bls.n	242c <yield+0x24>
			s_serials_with_serial_events[i]->doYieldCode();
    2478:	b2e3      	uxtb	r3, r4
    247a:	f857 5023 	ldr.w	r5, [r7, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    247e:	682b      	ldr	r3, [r5, #0]
    2480:	691b      	ldr	r3, [r3, #16]
    2482:	4628      	mov	r0, r5
    2484:	4798      	blx	r3
    2486:	2800      	cmp	r0, #0
    2488:	d0f1      	beq.n	246e <yield+0x66>
    248a:	692b      	ldr	r3, [r5, #16]
    248c:	4798      	blx	r3
    248e:	e7ee      	b.n	246e <yield+0x66>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    2490:	4b1c      	ldr	r3, [pc, #112]	; (2504 <yield+0xfc>)
    2492:	681b      	ldr	r3, [r3, #0]
    2494:	2b00      	cmp	r3, #0
    2496:	d0d1      	beq.n	243c <yield+0x34>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    2498:	f3ef 8305 	mrs	r3, IPSR
		if (ipsr != 0) return;
    249c:	2b00      	cmp	r3, #0
    249e:	d1cd      	bne.n	243c <yield+0x34>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    24a0:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    24a4:	b672      	cpsid	i
		EventResponder *first = firstYield;
    24a6:	4b17      	ldr	r3, [pc, #92]	; (2504 <yield+0xfc>)
    24a8:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    24aa:	b1a0      	cbz	r0, 24d6 <yield+0xce>
		if (runningFromYield) {
    24ac:	4b16      	ldr	r3, [pc, #88]	; (2508 <yield+0x100>)
    24ae:	781b      	ldrb	r3, [r3, #0]
    24b0:	b9ab      	cbnz	r3, 24de <yield+0xd6>
		runningFromYield = true;
    24b2:	4b15      	ldr	r3, [pc, #84]	; (2508 <yield+0x100>)
    24b4:	2101      	movs	r1, #1
    24b6:	7019      	strb	r1, [r3, #0]
		firstYield = first->_next;
    24b8:	6943      	ldr	r3, [r0, #20]
    24ba:	4912      	ldr	r1, [pc, #72]	; (2504 <yield+0xfc>)
    24bc:	600b      	str	r3, [r1, #0]
		if (firstYield) {
    24be:	b193      	cbz	r3, 24e6 <yield+0xde>
			firstYield->_prev = nullptr;
    24c0:	2100      	movs	r1, #0
    24c2:	6199      	str	r1, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    24c4:	b902      	cbnz	r2, 24c8 <yield+0xc0>
    24c6:	b662      	cpsie	i
		first->_triggered = false;
    24c8:	2400      	movs	r4, #0
    24ca:	7744      	strb	r4, [r0, #29]
		(*(first->_function))(*first);
    24cc:	6883      	ldr	r3, [r0, #8]
    24ce:	4798      	blx	r3
		runningFromYield = false;
    24d0:	4b0d      	ldr	r3, [pc, #52]	; (2508 <yield+0x100>)
    24d2:	701c      	strb	r4, [r3, #0]
    24d4:	e7b2      	b.n	243c <yield+0x34>
		if (doit) __enable_irq();
    24d6:	2a00      	cmp	r2, #0
    24d8:	d1b0      	bne.n	243c <yield+0x34>
    24da:	b662      	cpsie	i
    24dc:	e7ae      	b.n	243c <yield+0x34>
    24de:	2a00      	cmp	r2, #0
    24e0:	d1ac      	bne.n	243c <yield+0x34>
    24e2:	b662      	cpsie	i
    24e4:	e7aa      	b.n	243c <yield+0x34>
			lastYield = nullptr;
    24e6:	4b09      	ldr	r3, [pc, #36]	; (250c <yield+0x104>)
    24e8:	2100      	movs	r1, #0
    24ea:	6019      	str	r1, [r3, #0]
    24ec:	e7ea      	b.n	24c4 <yield+0xbc>
    24ee:	bf00      	nop
    24f0:	1fff8938 	.word	0x1fff8938
    24f4:	1fff8c79 	.word	0x1fff8c79
    24f8:	00002a38 	.word	0x00002a38
    24fc:	1fff8c9c 	.word	0x1fff8c9c
    2500:	1fff8c90 	.word	0x1fff8c90
    2504:	1fff8c7c 	.word	0x1fff8c7c
    2508:	1fff8c88 	.word	0x1fff8c88
    250c:	1fff8c8c 	.word	0x1fff8c8c

00002510 <EventResponder::runFromInterrupt()>:
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2510:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    2514:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2516:	4b11      	ldr	r3, [pc, #68]	; (255c <EventResponder::runFromInterrupt()+0x4c>)
    2518:	6818      	ldr	r0, [r3, #0]
		if (first) {
    251a:	b1d0      	cbz	r0, 2552 <EventResponder::runFromInterrupt()+0x42>
{
    251c:	b570      	push	{r4, r5, r6, lr}
			firstInterrupt = first->_next;
    251e:	461d      	mov	r5, r3
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    2520:	4e0f      	ldr	r6, [pc, #60]	; (2560 <EventResponder::runFromInterrupt()+0x50>)
    2522:	2400      	movs	r4, #0
    2524:	e009      	b.n	253a <EventResponder::runFromInterrupt()+0x2a>
    2526:	6034      	str	r4, [r6, #0]
    2528:	e00c      	b.n	2544 <EventResponder::runFromInterrupt()+0x34>
			}
			enableInterrupts(irq);
			first->_triggered = false;
    252a:	7744      	strb	r4, [r0, #29]
			(*(first->_function))(*first);
    252c:	6883      	ldr	r3, [r0, #8]
    252e:	4798      	blx	r3
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2530:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    2534:	b672      	cpsid	i
		EventResponder *first = firstInterrupt;
    2536:	6828      	ldr	r0, [r5, #0]
		if (first) {
    2538:	b140      	cbz	r0, 254c <EventResponder::runFromInterrupt()+0x3c>
			firstInterrupt = first->_next;
    253a:	6943      	ldr	r3, [r0, #20]
    253c:	602b      	str	r3, [r5, #0]
			if (firstInterrupt) {
    253e:	2b00      	cmp	r3, #0
    2540:	d0f1      	beq.n	2526 <EventResponder::runFromInterrupt()+0x16>
				firstInterrupt->_prev = nullptr;
    2542:	619c      	str	r4, [r3, #24]
		if (doit) __enable_irq();
    2544:	2a00      	cmp	r2, #0
    2546:	d1f0      	bne.n	252a <EventResponder::runFromInterrupt()+0x1a>
    2548:	b662      	cpsie	i
    254a:	e7ee      	b.n	252a <EventResponder::runFromInterrupt()+0x1a>
    254c:	b902      	cbnz	r2, 2550 <EventResponder::runFromInterrupt()+0x40>
    254e:	b662      	cpsie	i
		} else {
			enableInterrupts(irq);
			break;
		}
	}
}
    2550:	bd70      	pop	{r4, r5, r6, pc}
    2552:	b90a      	cbnz	r2, 2558 <EventResponder::runFromInterrupt()+0x48>
    2554:	b662      	cpsie	i
			break;
    2556:	4770      	bx	lr
    2558:	4770      	bx	lr
    255a:	bf00      	nop
    255c:	1fff8c84 	.word	0x1fff8c84
    2560:	1fff8c80 	.word	0x1fff8c80

00002564 <pendablesrvreq_isr>:
{
    2564:	b508      	push	{r3, lr}
	EventResponder::runFromInterrupt();
    2566:	f7ff ffd3 	bl	2510 <EventResponder::runFromInterrupt()>
}
    256a:	bd08      	pop	{r3, pc}

0000256c <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    256c:	4a02      	ldr	r2, [pc, #8]	; (2578 <systick_isr+0xc>)
    256e:	6813      	ldr	r3, [r2, #0]
    2570:	3301      	adds	r3, #1
    2572:	6013      	str	r3, [r2, #0]
}
    2574:	4770      	bx	lr
    2576:	bf00      	nop
    2578:	1fff8b6c 	.word	0x1fff8b6c

0000257c <analog_init>:
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    257c:	4b32      	ldr	r3, [pc, #200]	; (2648 <analog_init+0xcc>)
    257e:	2260      	movs	r2, #96	; 0x60
    2580:	701a      	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    2582:	22e1      	movs	r2, #225	; 0xe1
    2584:	705a      	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
    2586:	4b31      	ldr	r3, [pc, #196]	; (264c <analog_init+0xd0>)
    2588:	781b      	ldrb	r3, [r3, #0]
    258a:	2b08      	cmp	r3, #8
    258c:	d023      	beq.n	25d6 <analog_init+0x5a>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    258e:	2b0a      	cmp	r3, #10
    2590:	d02b      	beq.n	25ea <analog_init+0x6e>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    2592:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    2594:	4b2e      	ldr	r3, [pc, #184]	; (2650 <analog_init+0xd4>)
    2596:	bf0c      	ite	eq
    2598:	2115      	moveq	r1, #21
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    259a:	213d      	movne	r1, #61	; 0x3d
    259c:	6099      	str	r1, [r3, #8]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    259e:	2212      	movs	r2, #18
    25a0:	60da      	str	r2, [r3, #12]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    25a2:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
    25a6:	6099      	str	r1, [r3, #8]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    25a8:	60da      	str	r2, [r3, #12]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    25aa:	4b2a      	ldr	r3, [pc, #168]	; (2654 <analog_init+0xd8>)
    25ac:	781b      	ldrb	r3, [r3, #0]
    25ae:	b333      	cbz	r3, 25fe <analog_init+0x82>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    25b0:	2301      	movs	r3, #1
    25b2:	4a27      	ldr	r2, [pc, #156]	; (2650 <analog_init+0xd4>)
    25b4:	6213      	str	r3, [r2, #32]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    25b6:	f502 2200 	add.w	r2, r2, #524288	; 0x80000
    25ba:	6213      	str	r3, [r2, #32]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    25bc:	4b26      	ldr	r3, [pc, #152]	; (2658 <analog_init+0xdc>)
    25be:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
    25c0:	2b01      	cmp	r3, #1
    25c2:	d923      	bls.n	260c <analog_init+0x90>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    25c4:	2b04      	cmp	r3, #4
    25c6:	d82b      	bhi.n	2620 <analog_init+0xa4>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    25c8:	2384      	movs	r3, #132	; 0x84
    25ca:	4a21      	ldr	r2, [pc, #132]	; (2650 <analog_init+0xd4>)
    25cc:	6253      	str	r3, [r2, #36]	; 0x24
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    25ce:	f502 2200 	add.w	r2, r2, #524288	; 0x80000
    25d2:	6253      	str	r3, [r2, #36]	; 0x24
    25d4:	e020      	b.n	2618 <analog_init+0x9c>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    25d6:	4b1e      	ldr	r3, [pc, #120]	; (2650 <analog_init+0xd4>)
    25d8:	2101      	movs	r1, #1
    25da:	6099      	str	r1, [r3, #8]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    25dc:	2213      	movs	r2, #19
    25de:	60da      	str	r2, [r3, #12]
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    25e0:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
    25e4:	6099      	str	r1, [r3, #8]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    25e6:	60da      	str	r2, [r3, #12]
    25e8:	e7df      	b.n	25aa <analog_init+0x2e>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    25ea:	4b19      	ldr	r3, [pc, #100]	; (2650 <analog_init+0xd4>)
    25ec:	2119      	movs	r1, #25
    25ee:	6099      	str	r1, [r3, #8]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    25f0:	2213      	movs	r2, #19
    25f2:	60da      	str	r2, [r3, #12]
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    25f4:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
    25f8:	6099      	str	r1, [r3, #8]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    25fa:	60da      	str	r2, [r3, #12]
    25fc:	e7d5      	b.n	25aa <analog_init+0x2e>
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    25fe:	2300      	movs	r3, #0
    2600:	4a13      	ldr	r2, [pc, #76]	; (2650 <analog_init+0xd4>)
    2602:	6213      	str	r3, [r2, #32]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    2604:	f502 2200 	add.w	r2, r2, #524288	; 0x80000
    2608:	6213      	str	r3, [r2, #32]
    260a:	e7d7      	b.n	25bc <analog_init+0x40>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    260c:	2380      	movs	r3, #128	; 0x80
    260e:	4a10      	ldr	r2, [pc, #64]	; (2650 <analog_init+0xd4>)
    2610:	6253      	str	r3, [r2, #36]	; 0x24
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    2612:	f502 2200 	add.w	r2, r2, #524288	; 0x80000
    2616:	6253      	str	r3, [r2, #36]	; 0x24
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
		#endif
	}
	calibrating = 1;
    2618:	4b10      	ldr	r3, [pc, #64]	; (265c <analog_init+0xe0>)
    261a:	2201      	movs	r2, #1
    261c:	701a      	strb	r2, [r3, #0]
}
    261e:	4770      	bx	lr
	} else if (num <= 8) {
    2620:	2b08      	cmp	r3, #8
    2622:	d806      	bhi.n	2632 <analog_init+0xb6>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    2624:	2385      	movs	r3, #133	; 0x85
    2626:	4a0a      	ldr	r2, [pc, #40]	; (2650 <analog_init+0xd4>)
    2628:	6253      	str	r3, [r2, #36]	; 0x24
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    262a:	f502 2200 	add.w	r2, r2, #524288	; 0x80000
    262e:	6253      	str	r3, [r2, #36]	; 0x24
    2630:	e7f2      	b.n	2618 <analog_init+0x9c>
	} else if (num <= 16) {
    2632:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    2634:	bf94      	ite	ls
    2636:	2386      	movls	r3, #134	; 0x86
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    2638:	2387      	movhi	r3, #135	; 0x87
    263a:	4a05      	ldr	r2, [pc, #20]	; (2650 <analog_init+0xd4>)
    263c:	6253      	str	r3, [r2, #36]	; 0x24
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    263e:	f502 2200 	add.w	r2, r2, #524288	; 0x80000
    2642:	6253      	str	r3, [r2, #36]	; 0x24
    2644:	e7e8      	b.n	2618 <analog_init+0x9c>
    2646:	bf00      	nop
    2648:	40074000 	.word	0x40074000
    264c:	1fff8939 	.word	0x1fff8939
    2650:	4003b000 	.word	0x4003b000
    2654:	1fff8c9d 	.word	0x1fff8c9d
    2658:	1fff893a 	.word	0x1fff893a
    265c:	1fff8c9e 	.word	0x1fff8c9e

00002660 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
}
    2660:	4770      	bx	lr
    2662:	Address 0x0000000000002662 is out of bounds.


00002664 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    2664:	b500      	push	{lr}
    2666:	b085      	sub	sp, #20
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    2668:	b672      	cpsid	i
#if defined(HAS_KINETIS_FLASH_FTFA) || defined(HAS_KINETIS_FLASH_FTFL)
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    266a:	4b16      	ldr	r3, [pc, #88]	; (26c4 <usb_init_serialnumber+0x60>)
    266c:	2270      	movs	r2, #112	; 0x70
    266e:	701a      	strb	r2, [r3, #0]
	FTFL_FCCOB0 = 0x41;
    2670:	2241      	movs	r2, #65	; 0x41
    2672:	71da      	strb	r2, [r3, #7]
	FTFL_FCCOB1 = 15;
    2674:	220f      	movs	r2, #15
    2676:	719a      	strb	r2, [r3, #6]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    2678:	2280      	movs	r2, #128	; 0x80
    267a:	701a      	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    267c:	461a      	mov	r2, r3
    267e:	7813      	ldrb	r3, [r2, #0]
    2680:	f013 0f80 	tst.w	r3, #128	; 0x80
    2684:	d0fb      	beq.n	267e <usb_init_serialnumber+0x1a>
	num = *(uint32_t *)&FTFL_FCCOB7;
    2686:	4b0f      	ldr	r3, [pc, #60]	; (26c4 <usb_init_serialnumber+0x60>)
    2688:	6898      	ldr	r0, [r3, #8]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    268a:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    268c:	4b0e      	ldr	r3, [pc, #56]	; (26c8 <usb_init_serialnumber+0x64>)
    268e:	4298      	cmp	r0, r3
    2690:	bf3c      	itt	cc
    2692:	eb00 0080 	addcc.w	r0, r0, r0, lsl #2
    2696:	0040      	lslcc	r0, r0, #1
	ultoa(num, buf, 10);
    2698:	220a      	movs	r2, #10
    269a:	a901      	add	r1, sp, #4
    269c:	f7fe fed3 	bl	1446 <ultoa>
	for (i=0; i<10; i++) {
    26a0:	a901      	add	r1, sp, #4
    26a2:	480a      	ldr	r0, [pc, #40]	; (26cc <usb_init_serialnumber+0x68>)
    26a4:	2300      	movs	r3, #0
		char c = buf[i];
    26a6:	f811 2b01 	ldrb.w	r2, [r1], #1
		if (!c) break;
    26aa:	b122      	cbz	r2, 26b6 <usb_init_serialnumber+0x52>
		usb_string_serial_number_default.wString[i] = c;
    26ac:	f820 2f02 	strh.w	r2, [r0, #2]!
	for (i=0; i<10; i++) {
    26b0:	3301      	adds	r3, #1
    26b2:	2b0a      	cmp	r3, #10
    26b4:	d1f7      	bne.n	26a6 <usb_init_serialnumber+0x42>
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    26b6:	3301      	adds	r3, #1
    26b8:	005b      	lsls	r3, r3, #1
    26ba:	4a04      	ldr	r2, [pc, #16]	; (26cc <usb_init_serialnumber+0x68>)
    26bc:	7013      	strb	r3, [r2, #0]
}
    26be:	b005      	add	sp, #20
    26c0:	f85d fb04 	ldr.w	pc, [sp], #4
    26c4:	40020000 	.word	0x40020000
    26c8:	00989680 	.word	0x00989680
    26cc:	1fff89c8 	.word	0x1fff89c8

000026d0 <__aeabi_atexit>:
    26d0:	4603      	mov	r3, r0
    26d2:	4608      	mov	r0, r1
    26d4:	4619      	mov	r1, r3
    26d6:	f000 b853 	b.w	2780 <__cxa_atexit>
    26da:	bf00      	nop

000026dc <memset>:
    26dc:	0783      	lsls	r3, r0, #30
    26de:	b530      	push	{r4, r5, lr}
    26e0:	d048      	beq.n	2774 <memset+0x98>
    26e2:	1e54      	subs	r4, r2, #1
    26e4:	2a00      	cmp	r2, #0
    26e6:	d03f      	beq.n	2768 <memset+0x8c>
    26e8:	b2ca      	uxtb	r2, r1
    26ea:	4603      	mov	r3, r0
    26ec:	e001      	b.n	26f2 <memset+0x16>
    26ee:	3c01      	subs	r4, #1
    26f0:	d33a      	bcc.n	2768 <memset+0x8c>
    26f2:	f803 2b01 	strb.w	r2, [r3], #1
    26f6:	079d      	lsls	r5, r3, #30
    26f8:	d1f9      	bne.n	26ee <memset+0x12>
    26fa:	2c03      	cmp	r4, #3
    26fc:	d92d      	bls.n	275a <memset+0x7e>
    26fe:	b2cd      	uxtb	r5, r1
    2700:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    2704:	2c0f      	cmp	r4, #15
    2706:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    270a:	d936      	bls.n	277a <memset+0x9e>
    270c:	f1a4 0210 	sub.w	r2, r4, #16
    2710:	f022 0c0f 	bic.w	ip, r2, #15
    2714:	f103 0e20 	add.w	lr, r3, #32
    2718:	44e6      	add	lr, ip
    271a:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    271e:	f103 0210 	add.w	r2, r3, #16
    2722:	e942 5504 	strd	r5, r5, [r2, #-16]
    2726:	e942 5502 	strd	r5, r5, [r2, #-8]
    272a:	3210      	adds	r2, #16
    272c:	4572      	cmp	r2, lr
    272e:	d1f8      	bne.n	2722 <memset+0x46>
    2730:	f10c 0201 	add.w	r2, ip, #1
    2734:	f014 0f0c 	tst.w	r4, #12
    2738:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    273c:	f004 0c0f 	and.w	ip, r4, #15
    2740:	d013      	beq.n	276a <memset+0x8e>
    2742:	f1ac 0304 	sub.w	r3, ip, #4
    2746:	f023 0303 	bic.w	r3, r3, #3
    274a:	3304      	adds	r3, #4
    274c:	4413      	add	r3, r2
    274e:	f842 5b04 	str.w	r5, [r2], #4
    2752:	4293      	cmp	r3, r2
    2754:	d1fb      	bne.n	274e <memset+0x72>
    2756:	f00c 0403 	and.w	r4, ip, #3
    275a:	b12c      	cbz	r4, 2768 <memset+0x8c>
    275c:	b2c9      	uxtb	r1, r1
    275e:	441c      	add	r4, r3
    2760:	f803 1b01 	strb.w	r1, [r3], #1
    2764:	429c      	cmp	r4, r3
    2766:	d1fb      	bne.n	2760 <memset+0x84>
    2768:	bd30      	pop	{r4, r5, pc}
    276a:	4664      	mov	r4, ip
    276c:	4613      	mov	r3, r2
    276e:	2c00      	cmp	r4, #0
    2770:	d1f4      	bne.n	275c <memset+0x80>
    2772:	e7f9      	b.n	2768 <memset+0x8c>
    2774:	4603      	mov	r3, r0
    2776:	4614      	mov	r4, r2
    2778:	e7bf      	b.n	26fa <memset+0x1e>
    277a:	461a      	mov	r2, r3
    277c:	46a4      	mov	ip, r4
    277e:	e7e0      	b.n	2742 <memset+0x66>

00002780 <__cxa_atexit>:
    2780:	4613      	mov	r3, r2
    2782:	460a      	mov	r2, r1
    2784:	4601      	mov	r1, r0
    2786:	2002      	movs	r0, #2
    2788:	f000 b828 	b.w	27dc <__register_exitproc>

0000278c <__libc_init_array>:
    278c:	b570      	push	{r4, r5, r6, lr}
    278e:	4e0d      	ldr	r6, [pc, #52]	; (27c4 <__libc_init_array+0x38>)
    2790:	4d0d      	ldr	r5, [pc, #52]	; (27c8 <__libc_init_array+0x3c>)
    2792:	1b76      	subs	r6, r6, r5
    2794:	10b6      	asrs	r6, r6, #2
    2796:	d006      	beq.n	27a6 <__libc_init_array+0x1a>
    2798:	2400      	movs	r4, #0
    279a:	f855 3b04 	ldr.w	r3, [r5], #4
    279e:	3401      	adds	r4, #1
    27a0:	4798      	blx	r3
    27a2:	42a6      	cmp	r6, r4
    27a4:	d1f9      	bne.n	279a <__libc_init_array+0xe>
    27a6:	4e09      	ldr	r6, [pc, #36]	; (27cc <__libc_init_array+0x40>)
    27a8:	4d09      	ldr	r5, [pc, #36]	; (27d0 <__libc_init_array+0x44>)
    27aa:	1b76      	subs	r6, r6, r5
    27ac:	f000 f972 	bl	2a94 <_init>
    27b0:	10b6      	asrs	r6, r6, #2
    27b2:	d006      	beq.n	27c2 <__libc_init_array+0x36>
    27b4:	2400      	movs	r4, #0
    27b6:	f855 3b04 	ldr.w	r3, [r5], #4
    27ba:	3401      	adds	r4, #1
    27bc:	4798      	blx	r3
    27be:	42a6      	cmp	r6, r4
    27c0:	d1f9      	bne.n	27b6 <__libc_init_array+0x2a>
    27c2:	bd70      	pop	{r4, r5, r6, pc}
    27c4:	00002aa0 	.word	0x00002aa0
    27c8:	00002aa0 	.word	0x00002aa0
    27cc:	00002ab0 	.word	0x00002ab0
    27d0:	00002aa0 	.word	0x00002aa0

000027d4 <__retarget_lock_acquire_recursive>:
    27d4:	4770      	bx	lr
    27d6:	bf00      	nop

000027d8 <__retarget_lock_release_recursive>:
    27d8:	4770      	bx	lr
    27da:	bf00      	nop

000027dc <__register_exitproc>:
    27dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    27e0:	f8df a074 	ldr.w	sl, [pc, #116]	; 2858 <__register_exitproc+0x7c>
    27e4:	4606      	mov	r6, r0
    27e6:	f8da 0000 	ldr.w	r0, [sl]
    27ea:	4698      	mov	r8, r3
    27ec:	460f      	mov	r7, r1
    27ee:	4691      	mov	r9, r2
    27f0:	f7ff fff0 	bl	27d4 <__retarget_lock_acquire_recursive>
    27f4:	4b19      	ldr	r3, [pc, #100]	; (285c <__register_exitproc+0x80>)
    27f6:	681c      	ldr	r4, [r3, #0]
    27f8:	b324      	cbz	r4, 2844 <__register_exitproc+0x68>
    27fa:	6865      	ldr	r5, [r4, #4]
    27fc:	2d1f      	cmp	r5, #31
    27fe:	dc24      	bgt.n	284a <__register_exitproc+0x6e>
    2800:	b95e      	cbnz	r6, 281a <__register_exitproc+0x3e>
    2802:	1c6b      	adds	r3, r5, #1
    2804:	3502      	adds	r5, #2
    2806:	f8da 0000 	ldr.w	r0, [sl]
    280a:	6063      	str	r3, [r4, #4]
    280c:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
    2810:	f7ff ffe2 	bl	27d8 <__retarget_lock_release_recursive>
    2814:	2000      	movs	r0, #0
    2816:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    281a:	eb04 0185 	add.w	r1, r4, r5, lsl #2
    281e:	2301      	movs	r3, #1
    2820:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
    2824:	f8d4 2188 	ldr.w	r2, [r4, #392]	; 0x188
    2828:	40ab      	lsls	r3, r5
    282a:	431a      	orrs	r2, r3
    282c:	2e02      	cmp	r6, #2
    282e:	f8c4 2188 	str.w	r2, [r4, #392]	; 0x188
    2832:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
    2836:	d1e4      	bne.n	2802 <__register_exitproc+0x26>
    2838:	f8d4 218c 	ldr.w	r2, [r4, #396]	; 0x18c
    283c:	431a      	orrs	r2, r3
    283e:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    2842:	e7de      	b.n	2802 <__register_exitproc+0x26>
    2844:	4c06      	ldr	r4, [pc, #24]	; (2860 <__register_exitproc+0x84>)
    2846:	601c      	str	r4, [r3, #0]
    2848:	e7d7      	b.n	27fa <__register_exitproc+0x1e>
    284a:	f8da 0000 	ldr.w	r0, [sl]
    284e:	f7ff ffc3 	bl	27d8 <__retarget_lock_release_recursive>
    2852:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2856:	e7de      	b.n	2816 <__register_exitproc+0x3a>
    2858:	1fff89e0 	.word	0x1fff89e0
    285c:	1fff8e34 	.word	0x1fff8e34
    2860:	1fff8ca4 	.word	0x1fff8ca4

00002864 <register_fini>:
    2864:	4b02      	ldr	r3, [pc, #8]	; (2870 <register_fini+0xc>)
    2866:	b113      	cbz	r3, 286e <register_fini+0xa>
    2868:	4802      	ldr	r0, [pc, #8]	; (2874 <register_fini+0x10>)
    286a:	f000 b805 	b.w	2878 <atexit>
    286e:	4770      	bx	lr
    2870:	00000000 	.word	0x00000000
    2874:	00002885 	.word	0x00002885

00002878 <atexit>:
    2878:	2300      	movs	r3, #0
    287a:	4601      	mov	r1, r0
    287c:	461a      	mov	r2, r3
    287e:	4618      	mov	r0, r3
    2880:	f7ff bfac 	b.w	27dc <__register_exitproc>

00002884 <__libc_fini_array>:
    2884:	b538      	push	{r3, r4, r5, lr}
    2886:	4d07      	ldr	r5, [pc, #28]	; (28a4 <__libc_fini_array+0x20>)
    2888:	4c07      	ldr	r4, [pc, #28]	; (28a8 <__libc_fini_array+0x24>)
    288a:	1b2c      	subs	r4, r5, r4
    288c:	10a4      	asrs	r4, r4, #2
    288e:	d005      	beq.n	289c <__libc_fini_array+0x18>
    2890:	3c01      	subs	r4, #1
    2892:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    2896:	4798      	blx	r3
    2898:	2c00      	cmp	r4, #0
    289a:	d1f9      	bne.n	2890 <__libc_fini_array+0xc>
    289c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    28a0:	f000 b906 	b.w	2ab0 <__init_array_end>
	...
    28ac:	72617453 	.word	0x72617453
    28b0:	676e6974 	.word	0x676e6974
    28b4:	00000000 	.word	0x00000000
    28b8:	74746553 	.word	0x74746553
    28bc:	20676e69 	.word	0x20676e69
    28c0:	206c6c61 	.word	0x206c6c61
    28c4:	7344454c 	.word	0x7344454c
    28c8:	206f7420 	.word	0x206f7420
    28cc:	206d6964 	.word	0x206d6964
    28d0:	74696877 	.word	0x74696877
    28d4:	ffff0065 	.word	0xffff0065
    28d8:	20464f53 	.word	0x20464f53
    28dc:	65636552 	.word	0x65636552
    28e0:	64657669 	.word	0x64657669
    28e4:	00000000 	.word	0x00000000
    28e8:	206d754e 	.word	0x206d754e
    28ec:	65747962 	.word	0x65747962
    28f0:	65722073 	.word	0x65722073
    28f4:	76696563 	.word	0x76696563
    28f8:	203a6465 	.word	0x203a6465
    28fc:	ffffff00 	.word	0xffffff00

00002900 <digital_pin_to_info_PGM>:
    2900:	43fe0840 4004a040 43fe0844 4004a044     @..C@..@D..CD..@
    2910:	43fe1800 4004c000 43fe0030 40049030     ...C...@0..C0..@
    2920:	43fe0034 40049034 43fe181c 4004c01c     4..C4..@...C...@
    2930:	43fe1810 4004c010 43fe1808 4004c008     ...C...@...C...@
    2940:	43fe180c 4004c00c 43fe100c 4004b00c     ...C...@...C...@
    2950:	43fe1010 4004b010 43fe1018 4004b018     ...C...@...C...@
    2960:	43fe101c 4004b01c 43fe1014 4004b014     ...C...@...C...@
    2970:	43fe1804 4004c004 43fe1000 4004b000     ...C...@...C...@
    2980:	43fe0800 4004a000 43fe0804 4004a004     ...C...@...C...@
    2990:	43fe080c 4004a00c 43fe0808 4004a008     ...C...@...C...@
    29a0:	43fe1814 4004c014 43fe1818 4004c018     ...C...@...C...@
    29b0:	43fe1004 4004b004 43fe1008 4004b008     ...C...@...C...@
    29c0:	43fe0014 40049014 43fe084c 4004a04c     ...C...@L..CL..@
    29d0:	43fe2004 4004d004 43fe1024 4004b024     . .C...@$..C$..@
    29e0:	43fe1020 4004b020 43fe1028 4004b028      ..C ..@(..C(..@
    29f0:	43fe102c 4004b02c 43fe2000 4004d000     ,..C,..@. .C...@
    2a00:	43fe0848 4004a048 43fe0010 40049010     H..CH..@...C...@

00002a10 <vtable for usb_serial_class>:
	...
    2a18:	00001fdd 00001fd1 00001fc9 00001fc1     ................
    2a28:	00001fb9 00001fb1 00001fa9 00001fa1     ................

00002a38 <_serialEvent_default>:
    2a38:	ffffff00                                ....

00002a3c <usb_descriptor_list>:
    2a3c:	00000100 1fff8980 00000012 00000200     ................
    2a4c:	1fff893c 00000043 00000300 1fff8994     <...C...........
    2a5c:	00000000 04090301 1fff8998 00000000     ................
    2a6c:	04090302 1fff89b0 00000000 04090303     ................
    2a7c:	1fff89c8 00000000 00000000 00000000     ................
    2a8c:	00000000                                ....

00002a90 <usb_endpoint_config_table>:
    2a90:	15191500                                ....

00002a94 <_init>:
    2a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2a96:	bf00      	nop
    2a98:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2a9a:	bc08      	pop	{r3}
    2a9c:	469e      	mov	lr, r3
    2a9e:	4770      	bx	lr

00002aa0 <__init_array_start>:
    2aa0:	00002865 	.word	0x00002865

00002aa4 <__frame_dummy_init_array_entry>:
    2aa4:	00000435 000005e9 00000fa5              5...........

Disassembly of section .fini:

00002ab0 <_fini>:
    2ab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2ab2:	bf00      	nop
